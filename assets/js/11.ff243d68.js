(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{363:function(_,l,v){_.exports=v.p+"assets/img/8f4f3f002e8f6cb3f2366b67ab6a2660.8f4f3f00.png"},439:function(_,l,v){"use strict";v.r(l);var e=v(44),t=Object(e.a)({},(function(){var _=this,l=_.$createElement,e=_._self._c||l;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"_13-tcp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13-tcp"}},[_._v("#")]),_._v(" 13-TCP")]),_._v(" "),e("ul",[e("li",[e("p",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/77334450",target:"_blank",rel:"noopener noreferrer"}},[_._v("链接"),e("OutboundLink")],1)])]),_._v(" "),e("li",[e("p",[_._v("Raw Socket ：原始套接字，可以实现上至应用层，下至链路层（ISO七层模型）的数据操作")])]),_._v(" "),e("li",[e("p",[_._v("七层模型")]),_._v(" "),e("ul",[e("li",[_._v("应用，表示，会话，传输，网络，数据链路，物理")])])]),_._v(" "),e("li",[e("p",[_._v("五层模型")]),_._v(" "),e("ul",[e("li",[_._v("应用，传输，网络，数据链路，物理")])])]),_._v(" "),e("li",[e("p",[_._v("网络协议")]),_._v(" "),e("ul",[e("li",[_._v("从本质上来区分，HTTP，WebSocket，TCP，UDP，IP都是协议，而TCP/IP是不同协议的组合，你也可以称之为协议栈，协议族，TCP/IP模型等等")]),_._v(" "),e("li",[_._v("而Socket（套接字）才是真正能操作的东西。Socket的本质是API，是先人对TCP/IP协议族的抽象或者说封装，它就像一个门面，给你一个操作TCP/IP协议的入口，来建立Socket连接。值得一提的是，此Socket是指网络编程下的Socket，而不是Unix中的Socket。虽然概念相似，但是Unix中的Socket不是基于这些乱七八糟的协议，而是基于操作系统本身的文件系统")]),_._v(" "),e("li",[_._v("从分层上来区分，HTTP，WebSocket是应用层协议，TCP，UDP是传输层协议，IP是网络层协议")])])]),_._v(" "),e("li",[e("p",[_._v("TCP/IP模型")]),_._v(" "),e("ul",[e("li",[_._v("网络接口层：ARP（地址转换协议）、RARP（反向地址转换协议）")]),_._v(" "),e("li",[_._v("网际互联层：\n"),e("ul",[e("li",[_._v("ICMP（Internet Control Message Protocol）Internet控制报文协议、")]),_._v(" "),e("li",[_._v("IP（Internet Protocol）网际互连协议")])])]),_._v(" "),e("li",[_._v("传输层：TCP（Transmission Control Protocol）、UDP（User Datagram Protocol）\n"),e("ul",[e("li",[_._v("TCP是面向连接的一种传输控制协议。TCP连接之后，客户端和服务器可以互相发送和接收消息，在客户端或者服务器没有主动断开之前，连接一直存在，故称为长连接。特点：连接有耗时，传输数据无大小限制，准确可靠，先发先至")]),_._v(" "),e("li",[_._v("UDP是无连接的用户数据报协议，所谓的无连接就是在传输数据之前不需要交换信息，没有握手建立连接的过程，只需要直接将对应的数据发送到指定的地址和端口就行。故UDP的特点是不稳定，速度快，可广播，一般数据包限定64KB之内，先发未必先至。")])])]),_._v(" "),e("li",[_._v("应用层：DNS（基于UDP）、FTP（基于TCP）、HTTP（基于TCP）、WebSocket（基于TCP）、SMTP、TELNET、IRC、WHOIS")])])]),_._v(" "),e("li",[e("p",[_._v("HTTP、WebSocket与TCP的关系")]),_._v(" "),e("ul",[e("li",[_._v("HTTP通信过程属于“你推一下，我走一下”的方式，客户端不发请求则服务器永远无法发送数据给客户端，而WebSocket则在进行第一次HTTP请求之后，其他全部采用TCP通道进行双向通讯。所以，HTTP和WebSocket虽都是基于TCP协议，但是两者属于完全不同的两种通讯方式")])])]),_._v(" "),e("li",[e("p",[_._v("socket")]),_._v(" "),e("ul",[e("li",[_._v("应用层和TCP/IP协议族通信的中间软件抽象层，是一组接口。")])])]),_._v(" "),e("li",[e("p",[_._v("TCP协议")]),_._v(" "),e("ul",[e("li",[_._v("传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）")]),_._v(" "),e("li",[_._v("是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义")])])])]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("from socket import *\n\n# 创建socket\ntcp_server_socket = socket(AF_INET, SOCK_STREAM)\n\n# 本地信息\naddress = ('', 7788)\n\n# 绑定\ntcp_server_socket.bind(address)\n\n# 使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了\ntcp_server_socket.listen(128)\n\n# 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务\n# client_socket用来为这个客户端服务\n# tcp_server_socket就可以省下来专门等待其他新客户端的链接\nclient_socket, clientAddr = tcp_server_socket.accept()\n\n# 接收对方发送过来的数据\nrecv_data = client_socket.recv(1024) # 接收1024个字节\nprint('接收到的数据为:', recv_data.decode('gbk'))\n\n# 发送一些数据到客户端\nclient_socket.send(\"thank you !\".encode('gbk'))\n\n# 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接\nclient_socket.close()\n")])])]),e("ul",[e("li",[e("p",[_._v("特点：")]),_._v(" "),e("ul",[e("li",[e("span",{staticStyle:{"background-color":"#ffaaaa"}},[_._v("面向连接")]),_._v(" "),e("ul",[e("li",[_._v("双方建立连接才可以传输")]),_._v(" "),e("li",[_._v("一对一，不可以广播")]),_._v(" "),e("li",[_._v("三次握手，四次挥手")])])]),_._v(" "),e("li",[e("span",{staticStyle:{"background-color":"#ffaaaa"}},[_._v("可靠传输")]),_._v(" "),e("ul",[e("li",[_._v("发送应答机制")]),_._v(" "),e("li",[_._v("超时重传\n"),e("ul",[e("li",[_._v("发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段")])])]),_._v(" "),e("li",[_._v("错误校验")]),_._v(" "),e("li",[_._v("流量控制和阻塞重传\n"),e("ul",[e("li",[_._v("流量控制用来避免主机发送得过快而使接收方来不及完全收下")])])])])])])]),_._v(" "),e("li",[e("p",[_._v("其他注意点")]),_._v(" "),e("ul",[e("li",[_._v("关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。")]),_._v(" "),e("li",[_._v("当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线")])])]),_._v(" "),e("li",[e("p",[e("strong",[_._v("三次握手，")])])])]),_._v(" "),e("p",[e("strong",[e("img",{attrs:{src:v(363),alt:"8f4f3f002e8f6cb3f2366b67ab6a2660.png"}})])]),_._v(" "),e("ul",[e("li",[e("p",[e("strong",[_._v("题")])]),_._v(" "),e("ul",[e("li",[_._v("如果四次挥手第四次ack 一直收不到怎么办\n"),e("ul",[e("li",[_._v("TCP超时重传")]),_._v(" "),e("li",[_._v("TCP重传间隔时间和TCP重传次数\n"),e("ul",[e("li",[_._v("一般TCP报文的重传超时时间(RTO  Retransmission TimeOut)\n"),e("ul",[e("li",[_._v("TCP重传时间间隔有着多种不同的算法，最常见的就是《TCP/IP详解卷1》中关于超时重传的算法。具体算法不再赘述，请大家参考《TCP/IP详解卷1》第21章《TCP的超时与重传》。")])])]),_._v(" "),e("li",[_._v("SYN报文重传间隔时间\n"),e("ul",[e("li",[_._v("在实际情况下，由于SYN报文是TCP连接的第一个报文，如果该报文在传输的过程中丢弃了，那么发送方则无法测量RTT( Round Trip Time 连接往返时间)，也就无法根据RTT来计算RTO。因此，SYN重传的算法就要简单一些，SYN重传时间间隔一般根据系统实现的不同稍有差别，windows系统一般将第一次重传超时设为3秒，以后每次超时重传时间为上一次的2倍，")])])])])]),_._v(" "),e("li",[_._v("报文重传的次数\n"),e("ul",[e("li",[_._v("TCP报文重传的次数也根据系统设置的不同而有区分，有些系统，一个报文只会被重传3次，如果重传三次后还未收到该报文的确认，那么就不再尝试重传，直接reset重置该TCP连接，但有些要求很高的业务应用系统，则会不断的重传被丢弃的报文，以尽最大可能保证业务数据的正常交互。")])])])])]),_._v(" "),e("li",[_._v("为什么连接的时候是三次握手，关闭的时候却是四次握手？\n"),e("ul",[e("li",[_._v('因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，还要做一些其他的操作，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。')])])]),_._v(" "),e("li",[_._v("为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？\n"),e("ul",[e("li",[_._v("为了保证发送的最后一个ACK报文段能够到达B")]),_._v(" "),e("li",[_._v("防止“已失效的连接请求报文段”出现在本连接中。在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。")])])])])]),_._v(" "),e("li",[e("p",[_._v("Tips")]),_._v(" "),e("ul",[e("li",[_._v("ip： 负责传输的IP协议")]),_._v(" "),e("li",[_._v("tcp：确保可靠性的TCP协议")]),_._v(" "),e("li",[_._v("dns：负责域名解析")])])])]),_._v(" "),e("p")])}),[],!1,null,null,null);l.default=t.exports}}]);