(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{365:function(l,e,_){l.exports=_.p+"assets/img/ced5dfd71cdd44991fe56df35a2a8817.ced5dfd7.png"},453:function(l,e,_){"use strict";_.r(e);var v=_(44),i=Object(v.a)({},(function(){var l=this,e=l.$createElement,v=l._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[v("h1",{attrs:{id:"_41-celery-rabbitmq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_41-celery-rabbitmq"}},[l._v("#")]),l._v(" 41-celery，RabbitMq")]),l._v(" "),v("h1",{attrs:{id:"celery-分布式任务队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#celery-分布式任务队列"}},[l._v("#")]),l._v(" Celery - 分布式任务队列")]),l._v(" "),v("h2",{attrs:{id:"问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[l._v("#")]),l._v(" 问题：")]),l._v(" "),v("ol",[v("li",[l._v("讲下celery的作用及实现原理？\n"),v("ul",[v("li",[l._v("分布式任务队列管理工具，通过它可以轻松的实现任务的异步处理")]),l._v(" "),v("li",[l._v("使用场景\n"),v("ul",[v("li",[l._v("异步任务")]),l._v(" "),v("li",[l._v("定时任务")])])])])]),l._v(" "),v("li",[l._v("为什么使用celery异步任务？（类似于为什么使用消息队列）\n"),v("ol",[v("li",[l._v("异步")]),l._v(" "),v("li",[l._v("解耦：解决流程直接的耦合性")]),l._v(" "),v("li",[l._v("削峰：对于流量高峰，把请求放到队列里面，然后至于每秒消费多少请求，就看自己的服务器处理能力，不至于服务器崩溃")])])]),l._v(" "),v("li",[l._v("RabbitMq重复消费的问题\n"),v("ol",[v("li",[l._v("在redis做一个标记")])])]),l._v(" "),v("li",[l._v("RabbitMq消息如何处理")])]),l._v(" "),v("h2",{attrs:{id:"知识点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#知识点"}},[l._v("#")]),l._v(" 知识点")]),l._v(" "),v("ol",[v("li",[l._v("简介\n"),v("ol",[v("li",[l._v("一个由 Python 编写的简单、灵活、可靠的用来处理大量信息的分布式系统,")]),l._v(" "),v("li",[l._v("专注于实时任务处理，支持任务调度")]),l._v(" "),v("li",[l._v("一个分布式队列的管理工具")]),l._v(" "),v("li",[l._v("Celery 本身不是任务队列，它是管理分布式任务队列的工具")]),l._v(" "),v("li",[l._v("提供了对多种语言的支持")]),l._v(" "),v("li",[l._v("celery默认的并发方式是prefork,也就是多进程的方式，这里只是celery对multiprocessing.Pool进行了轻量的改造")])])]),l._v(" "),v("li",[l._v("优点\n"),v("ul",[v("li",[l._v("简单：一旦熟悉了celery的工作流程后，配置和使用还是比较简单的")]),l._v(" "),v("li",[l._v("高可用：当任务执行失败或执行过程中发生连接中断，celery 会自动尝试重新执行任务")]),l._v(" "),v("li",[l._v("快速：一个单进程的celery每分钟可处理上百万个任务")]),l._v(" "),v("li",[l._v("灵活： 几乎celery的各个组件都可以被扩展及自定制，\n"),v("ul",[v("li",[l._v("可以自制连接池、 序列化、压缩模式、日志、调度器、消费者、生产者、自动扩展、 中间人传输或更多。")])])])])]),l._v(" "),v("li",[l._v("支持\n"),v("ol",[v("li",[l._v("中间人")])]),l._v(" "),v("ul",[v("li",[l._v("RabbitMQ, Redis,")])]),l._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[l._v("并发\n"),v("ul",[v("li",[l._v("Eventlet, gevent")]),l._v(" "),v("li",[l._v("多线程/单线程")]),l._v(" "),v("li",[l._v("prefork（多进程）,")])])]),l._v(" "),v("li",[l._v("结果存储\n"),v("ul",[v("li",[l._v("AMQP, Redis")]),l._v(" "),v("li",[l._v("memcached, MongoDB， 关系型数据库")]),l._v(" "),v("li",[l._v("Apache Cassandra")])])]),l._v(" "),v("li",[l._v("序列化\n"),v("ul",[v("li",[l._v("zlib, bzip2 压缩")]),l._v(" "),v("li",[l._v("密码学消息签名")]),l._v(" "),v("li",[l._v("pickle, json, yaml, msgpack")])])])])]),l._v(" "),v("li",[l._v("架构\n"),v("ol",[v("li",[l._v("Celery Beat\n"),v("ul",[v("li",[l._v("是一个任务调度器，它以独立进程的形式存在。Celery beat 进程会读取配置文件的内容，周期性地将执行任务的请求发送给任务队列")]),l._v(" "),v("li",[l._v("Celery 系统自带的任务生产者")])])]),l._v(" "),v("li",[l._v("Producer\n"),v("ul",[v("li",[l._v("调用了Celery提供的API、函数或者装饰器而产生任务并交给任务队列处理的都是任务生产者")])])]),l._v(" "),v("li",[l._v("Broker\n"),v("ul",[v("li",[l._v("消息代理，或者叫作消息中间件，接受任务生产者发送过来的任务消息，存进队列再按序分发给任务消费方（通常是消息队列或者数据库）")])])]),l._v(" "),v("li",[l._v("celery worker\n"),v("ul",[v("li",[l._v("执行任务的一方，它负责接收处理任务中间方发来的任务处理请求，完成这些任务，并且返回任务处理的结果。")]),l._v(" "),v("li",[l._v("Celery worker 默认对应的就是操作系统中的一个进程，也可以是线程，协程")])])]),l._v(" "),v("li",[l._v("结果保存\n"),v("ul",[v("li",[l._v("支持任务处理完后将状态信息和结果的保存，以供查询")])])])])])]),l._v(" "),v("p",[v("img",{attrs:{src:_(365),alt:"ced5dfd71cdd44991fe56df35a2a8817.png"}})]),l._v(" "),v("ul",[v("li",[l._v("启动\n"),v("ul",[v("li",[v("span",{staticStyle:{"background-color":"#ffaaaa"}},[v("span",{staticStyle:{"background-color":"#ffaaaa"}},[l._v("celery  -A celery_tasks.main  worker  -l info  # 执行celery指令")])])]),l._v(" "),v("li",[l._v("$ celery -A tasks worker --loglevel=info")])])])]),l._v(" "),v("p",[l._v("开始编写tasks.py：")]),l._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[l._v("_# tasks.py_import time\n\nfrom celery import Celery\n\ncelery = Celery('tasks', broker='[redis://localhost:6379/0](redis://localhost:6379/0)')\n\n@celery.task\n\ndef sendmail(mail):\n\nprint('sending mail to %s...' % mail['to'])\n\ntime.sleep(2.0)\n\nprint('mail sent.')\n")])])]),v("p",[l._v("然后启动Celery处理任务： $ celery -A tasks worker --loglevel=info\n或者")]),l._v(" "),v("blockquote",[v("p",[l._v("from tasks import sendmail")])]),l._v(" "),v("blockquote",[v("p",[l._v("sendmail.delay(dict(to='"),v("a",{attrs:{href:"mailto:celery@python.org"}},[l._v("celery@python.org")]),l._v("'))")])]),l._v(" "),v("ul",[v("li",[l._v("链式任务\n"),v("ul",[v("li",[l._v("有些任务可能需由几个子任务组成，此时调用各个子任务的方式就变的很重要，尽量不要以同步阻塞的方式调用子任务，而是用异步回调的方式进行链式任务的调用：")])])]),l._v(" "),v("li",[l._v("调用任务\n"),v("ul",[v("li",[l._v("delay 只是 apply_async 的快捷方式，二者作用相同，只是 apply_async 可以进行更多的任务属性设置，比如 callbacks/errbacks 正常回调与错误回调、执行超时、重试、重试时间等等，")])])])])])}),[],!1,null,null,null);e.default=i.exports}}]);