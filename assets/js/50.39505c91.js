(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{416:function(_,v,t){"use strict";t.r(v);var e=t(44),p=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"_06-三大神器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_06-三大神器"}},[_._v("#")]),_._v(" 06-三大神器")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("知识点：")]),_._v(" "),t("ol",[t("li",[_._v("装饰器\n"),t("ol",[t("li",[_._v("装饰器本质上是一个 Python 函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的\n"),t("ul",[t("li",[_._v("闭包\n"),t("ul",[t("li",[_._v("在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包。")]),_._v(" "),t("li",[_._v("内部函数对外部函数作用域里变量的引用（非全局变量），则称内部函数为闭包")])])])])]),_._v(" "),t("li",[_._v("使用场景\n"),t("ol",[t("li",[_._v("参数检查，缓存，代理，提供上下文")])])])])]),_._v(" "),t("li",[_._v("迭代器（ Iterator）\n"),t("ol",[t("li",[_._v("迭代器是访问集合元素的一种方式")]),_._v(" "),t("li",[_._v("迭代器从集合的第一个元素开始访问，直到所有的元素被访问一遍后结束，迭代器只能前进不会后退")]),_._v(" "),t("li",[_._v("迭代器有两个基本的方法：next方法，返回下一个元素，")]),_._v(" "),t("li",[_._v("迭代（iteration）\n"),t("ul",[t("li",[_._v("用简单的话讲，它就是从某个地方（比如一个列表）取出一个元素的过程。当我们使用一个循环来遍历某个东西时，这个过程本身就叫迭代。")])])])])]),_._v(" "),t("li",[_._v("生成器\n"),t("ol",[t("li",[_._v("使用了yield的函数被称为生成器，")]),_._v(" "),t("li",[_._v("使用\n"),t("ol",[t("li",[_._v("你不想同一时间将所有计算出来的大量结果集分配到内存当中，特别是结果集里还包含循环")]),_._v(" "),t("li",[_._v("range Python2返回列表，Python3返回生成器")])])])])])])])]),_._v(" "),t("p",[_._v("装饰器：")]),_._v(" "),t("h3",{attrs:{id:""}},[t("a",{staticClass:"header-anchor",attrs:{href:"#"}},[_._v("#")])]),_._v(" "),t("h3",{attrs:{id:"例1-无参数的函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例1-无参数的函数"}},[_._v("#")]),_._v(" "),t("strong",[_._v("例1:无参数的函数")])]),_._v(" "),t("p",[_._v("from time import ctime, sleep")]),_._v(" "),t("p",[_._v("def timefun(func):")]),_._v(" "),t("p",[_._v("def wrapped_func():")]),_._v(" "),t("p",[_._v('print("%s called at %s" % (func.__name__, ctime()))')]),_._v(" "),t("p",[_._v("func()")]),_._v(" "),t("p",[_._v("return wrapped_func")]),_._v(" "),t("p",[_._v("@timefun")]),_._v(" "),t("p",[_._v("def foo():")]),_._v(" "),t("p",[_._v('print("I am foo")')]),_._v(" "),t("p",[_._v("foo()")]),_._v(" "),t("p",[_._v("sleep(2)")]),_._v(" "),t("p",[_._v("foo()")]),_._v(" "),t("p",[_._v("上面代码理解装饰器执行行为可理解成")]),_._v(" "),t("p",[_._v("foo = timefun(foo)")]),_._v(" "),t("p",[_._v("# foo先作为参数赋值给func后,foo接收指向timefun返回的wrapped_func")]),_._v(" "),t("p",[_._v("foo()")]),_._v(" "),t("p",[_._v("# 调用foo(),即等价调用wrapped_func()")]),_._v(" "),t("p",[_._v("# 内部函数wrapped_func被引用，所以外部函数的func变量(自由变量)并没有释放")]),_._v(" "),t("p",[_._v("# func里保存的是原foo函数对象")]),_._v(" "),t("h3",{attrs:{id:"例2-被装饰的函数有参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例2-被装饰的函数有参数"}},[_._v("#")]),_._v(" "),t("strong",[_._v("例2:被装饰的函数有参数")])]),_._v(" "),t("p",[_._v("from time import ctime, sleep")]),_._v(" "),t("p",[_._v("def timefun(func):")]),_._v(" "),t("p",[_._v("def wrapped_func(a, b):")]),_._v(" "),t("p",[_._v('print("%s called at %s" % (func.__name__, ctime()))')]),_._v(" "),t("p",[_._v("print(a, b)")]),_._v(" "),t("p",[_._v("func(a, b)")]),_._v(" "),t("p",[_._v("return wrapped_func")]),_._v(" "),t("p",[_._v("@timefun")]),_._v(" "),t("p",[_._v("def foo(a, b):")]),_._v(" "),t("p",[_._v("print(a+b)")]),_._v(" "),t("p",[_._v("foo(3,5)")]),_._v(" "),t("p",[_._v("sleep(2)")]),_._v(" "),t("p",[_._v("foo(2,4)")]),_._v(" "),t("h3",{attrs:{id:"例3-被装饰的函数有不定长参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例3-被装饰的函数有不定长参数"}},[_._v("#")]),_._v(" "),t("strong",[_._v("例3:被装饰的函数有不定长参数")])]),_._v(" "),t("p",[_._v("from time import ctime, sleep")]),_._v(" "),t("p",[_._v("def timefun(func):")]),_._v(" "),t("p",[_._v("def wrapped_func(*args, **kwargs):")]),_._v(" "),t("p",[_._v('print("%s called at %s"%(func.__name__, ctime()))')]),_._v(" "),t("p",[_._v("func(*args, **kwargs)")]),_._v(" "),t("p",[_._v("return wrapped_func")]),_._v(" "),t("p",[_._v("@timefun")]),_._v(" "),t("p",[_._v("def foo(a, b, c):")]),_._v(" "),t("p",[_._v("print(a+b+c)")]),_._v(" "),t("p",[_._v("foo(3,5,7)")]),_._v(" "),t("p",[_._v("sleep(2)")]),_._v(" "),t("p",[_._v("foo(2,4,9)")]),_._v(" "),t("h3",{attrs:{id:"例4-装饰器中的return"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例4-装饰器中的return"}},[_._v("#")]),_._v(" "),t("strong",[_._v("例4:装饰器中的return")])]),_._v(" "),t("p",[_._v("from time import ctime, sleep")]),_._v(" "),t("p",[_._v("def timefun(func):")]),_._v(" "),t("p",[_._v("def wrapped_func():")]),_._v(" "),t("p",[_._v('print("%s called at %s" % (func.__name__, ctime()))')]),_._v(" "),t("p",[_._v("ret = func()")]),_._v(" "),t("p",[_._v("return ret")]),_._v(" "),t("p",[_._v("return wrapped_func")]),_._v(" "),t("p",[_._v("@timefun")]),_._v(" "),t("p",[_._v("def foo():")]),_._v(" "),t("p",[_._v('print("I am foo")')]),_._v(" "),t("p",[_._v("@timefun")]),_._v(" "),t("p",[_._v("def getInfo():")]),_._v(" "),t("p",[_._v("return '----hahah---'")]),_._v(" "),t("p",[_._v("foo()")]),_._v(" "),t("p",[_._v("sleep(2)")]),_._v(" "),t("p",[_._v("foo()")]),_._v(" "),t("p",[_._v("print(getInfo())")]),_._v(" "),t("p",[_._v("执行结果:")]),_._v(" "),t("p",[_._v("foo called at Fri Nov 4 21:55:57 2016")]),_._v(" "),t("p",[_._v("I am foo")]),_._v(" "),t("p",[_._v("foo called at Fri Nov 4 21:55:59 2016")]),_._v(" "),t("p",[_._v("I am foo")]),_._v(" "),t("p",[_._v("getInfo called at Fri Nov 4 21:55:59 2016")]),_._v(" "),t("p",[_._v("----hahah---")]),_._v(" "),t("h4",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" "),t("strong",[_._v("总结：")])]),_._v(" "),t("ul",[t("li",[_._v("一般情况下为了让装饰器更通用，可以有return")])]),_._v(" "),t("h3",{attrs:{id:"例5-装饰器带参数-在原有装饰器的基础上-设置外部变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例5-装饰器带参数-在原有装饰器的基础上-设置外部变量"}},[_._v("#")]),_._v(" "),t("strong",[_._v("例5:装饰器带参数,在原有装饰器的基础上，设置外部变量")])]),_._v(" "),t("p",[_._v("#decorator2.py")]),_._v(" "),t("p",[_._v("from time import ctime, sleep")]),_._v(" "),t("p",[_._v('def timefun_arg(pre="hello"):')]),_._v(" "),t("p",[_._v("def timefun(func):")]),_._v(" "),t("p",[_._v("def wrapped_func():")]),_._v(" "),t("p",[_._v('print("%s called at %s %s" % (func.__name__, ctime(), pre))')]),_._v(" "),t("p",[_._v("return func()")]),_._v(" "),t("p",[_._v("return wrapped_func")]),_._v(" "),t("p",[_._v("return timefun")]),_._v(" "),t("p",[_._v("# 下面的装饰过程")]),_._v(" "),t("p",[_._v('# 1. 调用timefun_arg("itcast")')]),_._v(" "),t("p",[_._v("# 2. 将步骤1得到的返回值，即time_fun返回， 然后time_fun(foo)")]),_._v(" "),t("p",[_._v("# 3. 将time_fun(foo)的结果返回，即wrapped_func")]),_._v(" "),t("p",[_._v("# 4. 让foo = wrapped_fun，即foo现在指向wrapped_func")]),_._v(" "),t("p",[_._v('@timefun_arg("itcast")')]),_._v(" "),t("p",[_._v("def foo():")]),_._v(" "),t("p",[_._v('print("I am foo")')]),_._v(" "),t("p",[_._v('@timefun_arg("python")')]),_._v(" "),t("p",[_._v("def too():")]),_._v(" "),t("p",[_._v('print("I am too")')]),_._v(" "),t("p",[_._v("foo()")]),_._v(" "),t("p",[_._v("sleep(2)")]),_._v(" "),t("p",[_._v("foo()")]),_._v(" "),t("p",[_._v("too()")]),_._v(" "),t("p",[_._v("sleep(2)")]),_._v(" "),t("p",[_._v("too()")]),_._v(" "),t("p",[_._v("可以理解为")]),_._v(" "),t("p",[_._v('foo()==timefun_arg("itcast")(foo)()')]),_._v(" "),t("h3",{attrs:{id:"例6-类装饰器-扩展-非重点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例6-类装饰器-扩展-非重点"}},[_._v("#")]),_._v(" "),t("strong",[_._v("例6：类装饰器（扩展，非重点）")])]),_._v(" "),t("p",[_._v("装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重写了 __call__() 方法，那么这个对象就是callable的。")]),_._v(" "),t("p",[_._v("class Test():")]),_._v(" "),t("p",[_._v("def __call__(self):")]),_._v(" "),t("p",[_._v("print('call me!')")]),_._v(" "),t("p",[_._v("t = Test()")]),_._v(" "),t("p",[_._v("t() # call me")]),_._v(" "),t("p",[_._v("类装饰器demo")]),_._v(" "),t("p",[_._v("class Test(object):")]),_._v(" "),t("p",[_._v("def __init__(self, func):")]),_._v(" "),t("p",[_._v('print("---初始化---")')]),_._v(" "),t("p",[_._v('print("func name is %s"%func.__name__)')]),_._v(" "),t("p",[_._v("self.__func = func")]),_._v(" "),t("p",[_._v("def __call__(self):")]),_._v(" "),t("p",[_._v('print("---装饰器中的功能---")')]),_._v(" "),t("p",[_._v("self.__func()")]),_._v(" "),t("p",[_._v("#说明：")]),_._v(" "),t("p",[_._v("#1. 当用Test来装作装饰器对test函数进行装饰的时候，首先会创建Test的实例对象")]),_._v(" "),t("p",[_._v("# 并且会把func这个函数名当做参数传递到__init__方法中")]),_._v(" "),t("p",[_._v("# 即在__init__方法中的属性__func指向了func指向的函数")]),_._v(" "),t("p",[_._v("#2. func指向了用Test创建出来的实例对象#")]),_._v(" "),t("p",[_._v("#3. 当在使用test()进行调用时，就相当于让这个对象()，因此会调用这个对象的__call__方法#")]),_._v(" "),t("p",[_._v("#4. 为了能够在__call__方法中调用原来test指向的函数体，")]),_._v(" "),t("p",[_._v("所以在__init__方法中就需要一个实例属性来保存这个函数体的引用")]),_._v(" "),t("p",[_._v("# 所以才有了self.__func = func这句代码，从而在调用__call__方法中能够调用到test之前的函数体")]),_._v(" "),t("p",[_._v("@Test")]),_._v(" "),t("p",[_._v("def test():")]),_._v(" "),t("p",[_._v('print("----test---")')]),_._v(" "),t("p",[_._v("test()")]),_._v(" "),t("p",[_._v('showpy()#如果把这句话注释，重新运行程序，依然会看到"--初始化--"')]),_._v(" "),t("h3",{attrs:{id:"-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#-2"}},[_._v("#")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("题")]),_._v(" "),t("ol",[t("li",[_._v("带参数的装饰器有几层\n"),t("ol",[t("li",[_._v("在原函数外层加了三层")])])]),_._v(" "),t("li",[_._v("分别描述类装饰器和函数装饰器的实现过程以及应用场景\n"),t("ol",[t("li",[_._v("实现原理\n"),t("ul",[t("li",[_._v("类装饰器：")]),_._v(" "),t("li",[_._v("函数装饰器：")])])]),_._v(" "),t("li",[_._v("应用场景\n"),t("ul",[t("li",[_._v("插入日志、性能测试、事务处理、缓存、权限校验等")])])])])]),_._v(" "),t("li",[_._v("yield的作用\n"),t("ul",[t("li",[_._v("yield是一个关键词，类似return, 不同之处在于，yield返回的是一个生成器")]),_._v(" "),t("li",[_._v("而生成器是一种特殊的迭代器，它只会读取一次可迭代对象，实时生成数据，而不是读取可迭代对象的所有数据，相对而言会节约内存。")]),_._v(" "),t("li",[_._v("回到yield，当函数内部使用yield代替return后，在你调用时，并不会立即执行，而是返回一个生成器对象\n"),t("ul",[t("li",[_._v("可以借助for循环来遍历所以数据")]),_._v(" "),t("li",[_._v("也可以通过next方法来获取下一条数据")]),_._v(" "),t("li",[_._v("或者借助send传递附加数据")])])]),_._v(" "),t("li",[_._v("yield的作用：\n"),t("ul",[t("li",[_._v("保存当前运行状态（断点），然后暂停执行，即将生成器挂起")]),_._v(" "),t("li",[_._v("将yield关键字后面表达式的值作为返回值返回，")])])])])])])])])])}),[],!1,null,null,null);v.default=p.exports}}]);