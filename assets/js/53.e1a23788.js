(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{423:function(n,t,e){"use strict";e.r(t);var l=e(44),s=Object(l.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"_001-算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_001-算法"}},[n._v("#")]),n._v(" 001-算法")]),n._v(" "),e("ul",[e("li",[n._v("实现n！后结尾有多少个零，如n=4，n！=24，有0个0，n=5，n!=120，有1个0")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("def count_zero(n):\n    count = 0\n    if n>5:\n        k = n//5\n        count = k + count_zero(k)\n    return count\n   \n     # while num // 5 != 0:\n    # count += num // 5\n    # num = num //5\n    # return count\n")])])]),e("ul",[e("li",[n._v("给字符串，如“25525511123”实现算法，找出组成的ip地址的可能情况，如：['255.255.11.123','255.255.111.23']\n"),e("ul",[e("li",[n._v("回溯法 递归")]),n._v(" "),e("li",[n._v("depth first search(dfs,深度优先搜索)")])])])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class Solution(object):\n    def restoreIpAddresses(self, ip_str):\n    result = []\n    self.dfs(ip_str, [], result)\n    return result\n\ndef dfs(self, ip_str, ip_part, result):\n    if len(ip_str) > (4 - len(ip_part)) * 3:\n        return\n    if not ip_str and len(ip_part) == 4:\n        result.append('.'.join(ip_part))\n        return\n    for i in range(min(3, len(ip_str))):\n        curr = ip_str[:i + 1]\n        if (curr[0] == '0' and len(curr) >= 2) or int(curr) > 255:\n            continue\n        self.dfs(ip_str[i + 1:], ip_part + [ip_str[:i + 1]], result)\n")])])]),e("ul",[e("li",[n._v("给一个整数，如38，重复算出每个位数上数字之和，直至和为个位数，如3+8 =11，1+1 =2，满足条件，输出2")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("def count_zero(num):\n    while num >= 10:\n        num = num // 10 + num % 10\n    return num\n\ndef count_zero_plus(num):\n    num = 1 + (num - 1) % 9\n    print(num)\n")])])]),e("ul",[e("li",[n._v("给一个正整数 n, 找到若干个完全平方数(比如1, 4, 9, ... )使得他们的和等于 n。你需要让平方数的个数最少。\n"),e("ul",[e("li",[n._v("动态规划\n"),e("ul",[e("li",[n._v("通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，")]),n._v(" "),e("li",[n._v("每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。")]),n._v(" "),e("li",[n._v("适用情况\n"),e("ul",[e("li",[n._v("最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。")]),n._v(" "),e("li",[n._v("无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。")]),n._v(" "),e("li",[n._v("有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规")])])]),n._v(" "),e("li",[n._v("步骤：\n"),e("ul",[e("li",[n._v("初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态")])])]),n._v(" "),e("li",[n._v("使用场景：\n"),e("ul",[e("li",[n._v("使用递归求斐波那契数列的时候，可以使用一个字典来保存计算结果，每次递归时，若能在字典中找到解，则直接返回。减少冗余运算")])])])])])])])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class Solution(object):\n    _dp = [0]\n    def numSquares(self, n):\n        dp = self._dp\n        while len(dp) <= n:\n            # dp列表不断增大，dp[n]表示n的完美平方数\n            # ，将后面的int转换为 元组，然后执行+=操作\n            dp += min(dp[-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1,\n        return dp[n]\n")])])]),e("ul",[e("li",[n._v("请用两个队列实现一个栈\n"),e("ul",[e("li",[n._v("堆栈数据结构只允许在一端进行操作，按照后进先出（LIFO, Last In First Out）的原理运作")]),n._v(" "),e("li",[n._v("队列：是先进先出（FIFO, First-In-First-Out）的线性表")])])])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("伪代码\n1.栈为空：当两个队列都为空的时候，栈为空\n2.入栈操作：选择非空队列入栈，若都为空，则随意\n3.出栈操作：当两个队列都为空的时候，引发错误“栈为空”；\n    当队列Q2为空的时候，如果队列Q1中只有一个元素，则直接将队列1中的元素出队；\n    如果队列1不止一个元素的时候，就将队列Q1的元素出队然后入队到队列2，直到队列Q1中只有一个元素，然后将队列1中的元素出队即可。\n    当队列Q1为空的时候，如果队列Q2中只有一个元素，则直接将队列Q2中的元素出队；\n    如果队列Q2不止一个元素的时候，就将队列Q2的元素出队然后入队到队列Q1，直到队列Q2中只有一个元素，然后将队列2中的元素出队即可。\n")])])]),e("ul",[e("li",[n._v("跳表")])])])}),[],!1,null,null,null);t.default=s.exports}}]);