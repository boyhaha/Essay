(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{463:function(_,t,s){"use strict";s.r(t);var n=s(44),v=Object(n.a)({},(function(){var _=this,t=_.$createElement,s=_._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[s("h1",{attrs:{id:"_08-面向对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_08-面向对象"}},[_._v("#")]),_._v(" 08-面向对象")]),_._v(" "),s("h2",{attrs:{id:"问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[_._v("#")]),_._v(" "),s("strong",[_._v("问题")])]),_._v(" "),s("ol",[s("li",[_._v("实现with语句，要实现那个魔方方法\n"),s("ul",[s("li",[_._v("实现__enter__和__exit__方法后，就能通过with语句进行上下文管理")])])]),_._v(" "),s("li",[_._v("类方法、实例方法、静态方法的区别\n"),s("ol",[s("li",[_._v("类方法使用classmethod标识，静态方法使用@staticmethod 来修饰。实例方法就是剩下的方法")]),_._v(" "),s("li",[_._v("都可以通过类名或对象名进行调用，不过实例方法通过类名进行调用时需要传入一个对象参数。")])])])]),_._v(" "),s("h2",{attrs:{id:"面向对象基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面向对象基础"}},[_._v("#")]),_._v(" "),s("strong",[_._v("面向对象基础")])]),_._v(" "),s("ol",[s("li",[_._v("类\n"),s("ol",[s("li",[_._v("经典类（旧式类）：class Hero:                    class Hero():")]),_._v(" "),s("li",[_._v("新式类：class Hero( object ):")]),_._v(" "),s("li",[_._v("区别：新式类都从object继承，经典类不需要。\n"),s("ol",[s("li",[_._v("Python2中，经典类没有父类，新式类继承 object类")]),_._v(" "),s("li",[_._v("Python3中，经典类和新式类都继承 object 类")])])]),_._v(" "),s("li",[_._v("MRO(method resolution order 基类搜索顺序 / 多继承调用顺序)：\n"),s("ol",[s("li",[_._v("新式类：C3算法（广度优先搜索）")]),_._v(" "),s("li",[_._v("旧式类：深度优先搜索")]),_._v(" "),s("li",[_._v("新式类相同父类只执行一次构造函数，经典类重复执行多次。")])])])])])]),_._v(" "),s("p"),_._v(" "),s("h2",{attrs:{id:"面向对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面向对象"}},[_._v("#")]),_._v(" 面向对象")]),_._v(" "),s("ol",[s("li",[s("p",[_._v("面向对象")]),_._v(" "),s("ol",[s("li",[_._v("在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法\n"),s("ol",[s("li",[s("strong",[_._v("str")]),_._v("（ 必须有返回值）：返回一个字符串，作为这个对象的描述信息,追踪对象属性的变化；在使用print 输出时，默认打印对象的内存地址，如果类里面定义了__str__(self)方法，就会打印从这个方法中return的数据")]),_._v(" "),s("li",[s("strong",[_._v("del")]),_._v("()方法：经常会在  "),s("strong",[_._v("del")]),_._v("() 方法中做一些处理\n"),s("ol",[s("li",[_._v("当有变量保存了一个对象的引用时，该对象的引用计数就会加  1")]),_._v(" "),s("li",[_._v("使用 del 删除变量指向的对象时，就会减少对象的引用计数（每次减 1 ），当引用计数为0 时，对象才会真的被删除（内存被回收）")])])]),_._v(" "),s("li",[_._v("__new__方法\n"),s("ol",[s("li",[_._v("__new__至少要有一个参数cls，代表要实例化的类")]),_._v(" "),s("li",[_._v("__new__必须要有返回值，返回实例化出来的实例。可以return父类__new__出来的实例，或者直接是object的__new__出来的实例")]),_._v(" "),s("li",[_._v("return  object."),s("strong",[_._v("new")]),_._v("(cls)")])])])])])])]),_._v(" "),s("li",[s("p",[_._v("继承")]),_._v(" "),s("ol",[s("li",[_._v("继承，子类会继承父类的__init__方法，所以子类会继承父类的属性")]),_._v(" "),s("li",[_._v("调用父类方法：\n"),s("ol",[s("li",[_._v("super(child_class, child_object).parent_attribute(arg)\n"),s("ol",[s("li",[_._v("super(FooChild, self)."),s("strong",[_._v("init")]),_._v("()")]),_._v(" "),s("li",[_._v("super(FooChild, self).bar(message)")])])]),_._v(" "),s("li",[_._v("使用super() 可以逐一调用所有的父类方法，并且只执行一次。调用顺序遵循 mro 类属性的顺序。")]),_._v(" "),s("li",[_._v("super() 带参数版本，只支持新式类\n"),s("ul",[s("li",[_._v("super(cls, self).make_cake()")])])]),_._v(" "),s("li",[_._v("super()的简化版，只支持新式类\n"),s("ul",[s("li",[_._v("super().make_cake()")])])]),_._v(" "),s("li",[_._v("如果继承了多个父类，且父类都有同名方法，则默认只执行第一个父类的(同名方法只执行一次，目前super()不支持执行多个父类的同名方法)")])])]),_._v(" "),s("li",[_._v("所以在以后的开发中，如果重写了父类的__init__方法，最好是先调用父类的这个方法，然后再添加自己的功能，（完成父类的初始化工作，以保证程序的稳定）")])])]),_._v(" "),s("li",[s("p",[_._v("封装")]),_._v(" "),s("ol",[s("li",[_._v("封装的意义：\n"),s("ol",[s("li",[_._v("将属性和方法放到一起作为一个整体，然后通过实例化对象来处理")]),_._v(" "),s("li",[_._v("隐藏内部细节，只需要和对象的方法和属性进行交互")]),_._v(" "),s("li",[_._v("可以对属性和方法增加权限")])])]),_._v(" "),s("li",[_._v("私有权限：在属性名或方法名前面加两个下划线__\n"),s("ol",[s("li",[_._v("不能通过对象处理，起到安全作用")]),_._v(" "),s("li",[_._v("如果子类继承了父类，子类就是继承父类的共有属性和共有方法，子类不能直接使用父类的私有属性和私有方法\n"),s("ol",[s("li",[_._v("子类可以调用父类的私有属性和私有方法，但是不合法")])])])])]),_._v(" "),s("li",[_._v("dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型 列表；")]),_._v(" "),s("li",[_._v("带参数时，返回参数的属性、方法 列表。\n"),s("ol",[s("li",[_._v("如果参数包含方法__dir__()，该方法将被调用。")]),_._v(" "),s("li",[_._v("如果参数不包含__dir__()，该方法将最大限度地收集参数信息。")])])])])]),_._v(" "),s("li",[s("p",[_._v("多态 （定义时的类型和运行时的类型不一样，此时就称为多态）")]),_._v(" "),s("ol",[s("li",[_._v("Python的多态，就是弱化类型（鸭子类型），重点在于对象参数是否有指定的属性和方法，如果有就认定合适，而不关心对象的类型是否正确。\n"),s("ol",[s("li",[_._v("传入不同的对象，（类型不同）")]),_._v(" "),s("li",[_._v("都有相同的属性和方法，可以正常访问，称为多态")]),_._v(" "),s("li",[_._v("多态的作用：增强一个函数或者方法的复用性")])])])])]),_._v(" "),s("li",[s("p",[_._v("类属性和实例属性")]),_._v(" "),s("ol",[s("li",[_._v("类属性：就是类对象所拥有的属性，被所有类对象的实例对象所共有，在内存中值存在一个副本，类似于C++中的静态对象")]),_._v(" "),s("li",[_._v("实例属性：对象属性，无法通过"),s("strong",[_._v("类名.属性名")]),_._v("进行访问")]),_._v(" "),s("li",[_._v("如果一个类有多个对象，每个对象的属性是各自保存的，都有各自独立的地址")]),_._v(" "),s("li",[_._v("如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性")])])]),_._v(" "),s("li",[s("p",[_._v("类方法和静态方法")]),_._v(" "),s("ol",[s("li",[_._v("类方法：修饰器@classmethod来标识其为类方法，（一般以cls作为第一个参数）")]),_._v(" "),s("li",[_._v("静态方法：通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数，可以通过对象和类来访问")])])]),_._v(" "),s("li",[s("p",[_._v("单例模式")]),_._v(" "),s("ol",[s("li",[_._v("确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，单例模式是一种对象创建型模式。")]),_._v(" "),s("li",[_._v("保证只有1个对象")]),_._v(" "),s("li",[_._v("只执行一次__init__方法")]),_._v(" "),s("li",[_._v("示例："),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[_._v("     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("class")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[_._v("Singleton")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[_._v("object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(":")]),_._v("\n        __instance "),s("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[_._v("None")]),_._v("\n        __is_first "),s("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[_._v("True")]),_._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("def")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[_._v("__new__")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("cls"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" age"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(":")]),_._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 实例化")]),_._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("if")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("not")]),_._v(" cls"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v("__instance"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(":")]),_._v("\n                cls"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v("__instance "),s("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[_._v("object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v("__new__"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("cls"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("return")]),_._v(" cls"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v("__instance\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("def")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[_._v("__init__")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" age"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(":")]),_._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 初始化")]),_._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("if")]),_._v(" self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v(" __is_first"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(":")]),_._v("\n                self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v("age "),s("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" age\n                self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v("name "),s("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" name\n                Singleton"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v(" __is_first "),s("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[_._v("False")]),_._v("\n")])])])])])])]),_._v(" "),s("p"),_._v(" "),s("h2",{attrs:{id:"概念知识"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概念知识"}},[_._v("#")]),_._v(" 概念知识：")]),_._v(" "),s("ol",[s("li",[_._v("面向对象（object oriented programing  OOP）：\n"),s("ol",[s("li",[_._v("博大，将一类事物的共同属性进行抽象，将其所有的属性、行为按功能进行集合；")]),_._v(" "),s("li",[_._v("把事物分解成不同的对象，建立对象的目的不是完成某一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为")]),_._v(" "),s("li",[_._v("可以加快开发速度，减少代码重复")])])]),_._v(" "),s("li",[_._v("面向过程（ procedure oriented programing  POP）：\n"),s("ol",[s("li",[_._v("精深，思考到事物发展的每一步，细发如丝，考虑到任何一种可能发生的情况，一步步执行，判断，直至事物的结束。")]),_._v(" "),s("li",[_._v("根据业务逻辑用函数把这些步骤一步步实现，然后在一一调用（自顶向下，逐步细化）")]),_._v(" "),s("li",[_._v("随着系统的膨胀，面向过程将无法应付，最终崩溃")])])]),_._v(" "),s("li",[_._v("OOP, POP 优缺点：\n"),s("ol",[s("li",[_._v("面型对象：\n"),s("ol",[s("li",[_._v("易维护、复用、扩展，系统使用灵活方便；")]),_._v(" "),s("li",[_._v("性能低于面向过程")])])]),_._v(" "),s("li",[_._v("面向过程：\n"),s("ol",[s("li",[_._v("性能更优，消耗资源少")]),_._v(" "),s("li",[_._v("难以维护、复用、扩展。")])])])])]),_._v(" "),s("li",[_._v("类：具有相似内部状态和运动规律的实体集合（或抽象）")]),_._v(" "),s("li",[_._v("对象：某一个类的具体存在")])]),_._v(" "),s("p"),_._v(" "),s("p")])}),[],!1,null,null,null);t.default=v.exports}}]);