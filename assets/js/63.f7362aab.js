(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{427:function(v,l,_){"use strict";_.r(l);var i=_(44),e=Object(i.a)({},(function(){var v=this,l=v.$createElement,_=v._self._c||l;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"_22-redis"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_22-redis"}},[v._v("#")]),v._v(" 22-Redis")]),v._v(" "),_("p",[v._v("问题")]),v._v(" "),_("ul",[_("li",[v._v("什么\n"),_("ul",[_("li",[v._v("Redis是一个开源的内存中的数据结构存储系统，它可以用作："),_("strong",[v._v("数据库、缓存和消息中间件")])]),v._v(" "),_("li",[v._v("采用的是"),_("strong",[v._v("单进程单线程")]),v._v("模型的 "),_("strong",[v._v("KV 数据库")]),v._v("，"),_("strong",[v._v("由C语言编写")])])])]),v._v(" "),_("li",[v._v("有哪些数据结构？\n"),_("ul",[_("li",[v._v("字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。")])])]),v._v(" "),_("li",[v._v("为什么是单线程的\n"),_("ul",[_("li",[v._v("因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。")])])]),v._v(" "),_("li",[v._v("为什么redis是单线程还这么快？\n"),_("ol",[_("li",[v._v("完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；")]),v._v(" "),_("li",[v._v("数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；")]),v._v(" "),_("li",[v._v("采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；")]),v._v(" "),_("li",[v._v("使用多路I/O复用模型，非阻塞IO；\n"),_("ul",[_("li",[v._v("多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。")]),v._v(" "),_("li",[v._v("**这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。**采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。")])])]),v._v(" "),_("li",[v._v("使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；")])])]),v._v(" "),_("li",[v._v("Redis会使用CRC16算法，将键和值写到某个节点上")]),v._v(" "),_("li",[v._v("redis内存淘汰策略\n"),_("ul",[_("li",[v._v("volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰")]),v._v(" "),_("li",[v._v("volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰")]),v._v(" "),_("li",[v._v("volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰")]),v._v(" "),_("li",[v._v("allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰")]),v._v(" "),_("li",[v._v("allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰")]),v._v(" "),_("li",[v._v("noeviction：禁止驱逐数据，当内存使用达到阈值的时候，所有引起申请内存的命令会报错")])])]),v._v(" "),_("li",[v._v("内存淘汰算法--LRU\n"),_("ul",[_("li",[v._v("将空闲时间最长的淘汰掉\n"),_("ul",[_("li",[v._v("Redis3.0会提供一个待淘汰候选key的pool，里面默认有16个key，按照空闲时间排好序。更新时从Redis键空间随机选择N个key，分别计算它们的空闲时间idle，key只会在pool不满或者空闲时间大于pool里最小的时，才会进入pool，然后从pool中选择空闲时间最大的key淘汰掉。")])])])])]),v._v(" "),_("li",[v._v("Redis\n"),_("ul",[_("li",[v._v("优点\n"),_("ul",[_("li",[v._v("读写性能优异")]),v._v(" "),_("li",[v._v("支持数据持久化")]),v._v(" "),_("li",[v._v("支持主从复制，可以进行读写分离")]),v._v(" "),_("li",[v._v("数据结构丰富")])])]),v._v(" "),_("li",[v._v("缺点\n"),_("ul",[_("li",[v._v("数据库容量受到物理内存的限制,不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上")]),v._v(" "),_("li",[v._v("可用性比较低")]),v._v(" "),_("li",[v._v("主从复制是全量复制，比较消耗资源")])])])])]),v._v(" "),_("li",[v._v("持久化方案\n"),_("ul",[_("li",[v._v("RDB（默认）\n"),_("ul",[_("li",[v._v("采用")]),v._v(" "),_("li",[v._v("fork出一个子进程进行持久化，并替换rdb文件")]),v._v(" "),_("li",[v._v("会出现数据丢失")])])]),v._v(" "),_("li",[v._v("AOF\n"),_("ul",[_("li",[v._v("AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过"),_("strong",[v._v("回放")]),v._v(" AOF 日志中的写入指令来重新构建整个数据集。")]),v._v(" "),_("li",[v._v("可以有很多不同的fsync策略：没有fsync，每秒fsync（默认），每次请求时fsync")]),v._v(" "),_("li",[v._v("当AOF文件变得很大时，Redis会自动在后台进行重写。重写是绝对安全的，因为Redis继续往旧的文件中追加，使用创建当前数据集所需的最小操作集合来创建一个全新的文件，一旦第二个文件创建完毕，Redis就会切换这两个文件，并开始往新文件追加。")])])])])]),v._v(" "),_("li",[v._v("常见概念\n"),_("ul",[_("li",[v._v("缓存雪崩\n"),_("ul",[_("li",[v._v("当Redis服务器重启或者大量缓存在同一时期失效时,此时大量的流量会全部冲击到数据库上面,数据库有可能会因为承受不住而宕机")]),v._v(" "),_("li",[v._v("解决办法\n"),_("ul",[_("li",[_("strong",[v._v("均匀分布")])]),v._v(" "),_("li",[_("strong",[v._v("熔断机制")])]),v._v(" "),_("li",[_("strong",[v._v("限流机制")])]),v._v(" "),_("li",[v._v("设置过期标志跟新缓存")])])])])]),v._v(" "),_("li",[v._v("缓存穿透\n"),_("ul",[_("li",[v._v("缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）")]),v._v(" "),_("li",[v._v("解决办法\n"),_("ul",[_("li",[_("strong",[v._v("布隆过滤")])]),v._v(" "),_("li",[_("strong",[v._v("缓存空值")])])])])])]),v._v(" "),_("li",[v._v("缓存预热\n"),_("ul",[_("li",[v._v("系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题")]),v._v(" "),_("li",[v._v("解决办法\n"),_("ul",[_("li",[v._v("项目启动，自动缓存")]),v._v(" "),_("li",[v._v("定时刷新缓存")])])])])]),v._v(" "),_("li",[v._v("服务降级\n"),_("ul",[_("li",[v._v("服务降级是不得已而为之的,在关键的时候丢卒保帅,保证核心功能正常运行")]),v._v(" "),_("li",[_("strong",[v._v("服务拒绝")])]),v._v(" "),_("li",[_("strong",[v._v("服务延迟")])])])])])]),v._v(" "),_("li",[v._v("教训\n"),_("ul",[_("li",[v._v("要进行Master-slave配置，出现服务故障时可以支持切换")]),v._v(" "),_("li",[v._v("当达到最大内存时，会清空带有过期时间的key，即使key未到过期时间.")]),v._v(" "),_("li",[v._v("redis与DB同步写的问题，先写DB，后写redis，因为写内存基本上没有问题")]),v._v(" "),_("li",[v._v("当Redis物理内存使用超过内存总容量的3/5时就会开始比较危险了，就开始做swap,内存碎片大")])])])]),v._v(" "),_("p",[v._v("基础")]),v._v(" "),_("ul",[_("li",[v._v("redis是key-value的数据结构，每条数据都是一个键值对")]),v._v(" "),_("li",[v._v("键 Key\n"),_("ul",[_("li",[v._v("del")]),v._v(" "),_("li",[v._v("keys")]),v._v(" "),_("li",[v._v("exists")]),v._v(" "),_("li",[v._v("EXPIRE key seconds\n"),_("ul",[_("li",[v._v("设置生存时间")])])]),v._v(" "),_("li",[v._v("sort\n"),_("ul",[_("li",[v._v("排序")])])])])]),v._v(" "),_("li",[v._v("值的类型\n"),_("ul",[_("li",[v._v("string\n"),_("ul",[_("li",[v._v("APPEND key value\n"),_("ul",[_("li",[v._v("如果 key 已经存在并且是一个字符串，")])])]),v._v(" "),_("li",[v._v("INCRBY key increment\n"),_("ul",[_("li",[v._v("将 key 所储存的值加上增量 increment 。")])])]),v._v(" "),_("li",[v._v("STRLEN key\n"),_("ul",[_("li",[v._v("返回 key 所储存的字符串值的长度。")])])]),v._v(" "),_("li",[v._v("SETNX key value\n"),_("ul",[_("li",[v._v("将")])])])])]),v._v(" "),_("li",[v._v("hash\n"),_("ul",[_("li",[v._v("HGETALL key\n"),_("ul",[_("li",[v._v("返回哈希表")])])]),v._v(" "),_("li",[v._v("HKEYS key\n"),_("ul",[_("li",[v._v("返回哈希表")])])]),v._v(" "),_("li",[v._v("HVALS key\n"),_("ul",[_("li",[v._v("返回哈希表")])])]),v._v(" "),_("li",[v._v("HLEN key\n"),_("ul",[_("li",[v._v("返回哈希表")])])]),v._v(" "),_("li",[v._v("HSTRLEN key field\n"),_("ul",[_("li",[v._v("返回哈希表")])])])])]),v._v(" "),_("li",[v._v("list\n"),_("ul",[_("li",[v._v("LLEN key\n"),_("ul",[_("li",[v._v("返回列表")])])]),v._v(" "),_("li",[v._v("LINSERT key BEFORE|AFTER pivot value\n"),_("ul",[_("li",[v._v("将值")])])]),v._v(" "),_("li",[v._v("LPUSH key value [value ...]\n"),_("ul",[_("li",[v._v("将一个或多个值")])])]),v._v(" "),_("li",[v._v("LPOP key\n"),_("ul",[_("li",[v._v("移除并返回列表")])])]),v._v(" "),_("li",[v._v("LRANGE key start stop\n"),_("ul",[_("li",[v._v("返回列表")])])]),v._v(" "),_("li",[v._v("LREM key count value\n"),_("ul",[_("li",[v._v("根据参数")])])])])]),v._v(" "),_("li",[v._v("set\n"),_("ul",[_("li",[v._v("SREM key member [member ...]\n"),_("ul",[_("li",[v._v("移除集合\n"),_("ul",[_("li",[v._v("O(N)，")])])])])])])]),v._v(" "),_("li",[v._v("sortedset")])])])])])}),[],!1,null,null,null);l.default=e.exports}}]);