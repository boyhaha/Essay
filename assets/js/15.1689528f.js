(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{374:function(e,n,o){e.exports=o.p+"assets/img/f115ee9d88f95aac3be324d42b6dfb35.f115ee9d.gif"},459:function(e,n,o){"use strict";o.r(n);var t=o(44),r=Object(t.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_62-树相关"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_62-树相关"}},[e._v("#")]),e._v(" 62-树相关")]),e._v(" "),t("p",[t("strong",[e._v("深度优先****搜索")])]),e._v(" "),t("ul",[t("li",[e._v("深度（Depth）优先搜索是一种先遍历子节点而不回溯的图遍历算法")]),e._v(" "),t("li",[e._v("时间复杂度：O(|V| + |E|)")])]),e._v(" "),t("p",[t("strong",[e._v("广度优先****搜索")])]),e._v(" "),t("ul",[t("li",[e._v("广度（Breadth）优先搜索是一种先遍历邻居节点而不是子节点的图遍历算法")]),e._v(" "),t("li",[e._v("时间复杂度：O(|V| + |E|)")])]),e._v(" "),t("p",[t("img",{attrs:{src:o(374),alt:"f115ee9d88f95aac3be324d42b6dfb35.gif"}})]),e._v(" "),t("h2",{attrs:{id:"树的四种遍历方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#树的四种遍历方式"}},[e._v("#")]),e._v(" "),t("strong",[e._v("树的四种遍历方式")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Node():\n    # 节点类\n    def __init__(self, data=-1):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass Tree():\n    # 树类\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, data):\n        # 为树加入节点\n        node = Node(data)\n        if self.root.data == -1:  # 如果树为空，就对根节点赋值\n            self.root = node\n        else:\n            myQueue = []\n            treeNode = self.root\n            myQueue.append(treeNode)\n            while myQueue:  # 对已有的节点进行层次遍历\n                treeNode = myQueue.pop(0)\n                if not treeNode.left:\n                    treeNode.left = node\n                    return\n                elif not treeNode.right:\n                    treeNode.right = node\n                    return\n                else:\n                    myQueue.append(treeNode.left)\n                    myQueue.append(treeNode.right)\n\n    def pre_order_recursion(self, root):  # 递归实现前序遍历   根左右\n        if not root:\n            return\n        print(root.data),\n        self.pre_order_recursion(root.left)\n        self.pre_order_recursion(root.right)\n\n    def in_order_recursion(self, root):  # 递归实现中序遍历   左根右\n        if not root:\n            return\n        self.in_order_recursion(root.left)\n        print(root.data),\n        self.in_order_recursion(root.right)\n\n    \n    def post_order_recursion(self, root):  # 递归实现后序遍历   左右根\n        if not root:\n            return\n        self.post_order_recursion(root.left)\n        self.post_order_recursion(root.right)\n        print(root.data),\n\n    def level_order_queue(self, root):  # 队列实现层次遍历（非递归）\n        if not root:\n            return\n        myQueue = []\n        node = root\n        myQueue.append(node)\n        while myQueue:\n            node = myQueue.pop(0)\n            print(node.data),\n            if node.left:\n                myQueue.append(node.left)\n            if node.right:\n                myQueue.append(node.right)\n\n    def pre_order_stack(self, root):  # 堆栈实现前序遍历（非递归）\n        if not root:\n            return\n        myStack = []\n        node = root\n        while myStack or node:\n            while node:  # 从根节点开始，一直寻找他的左子树\n                print(node.data)\n                myStack.append(node)\n                node = node.left\n            node = myStack.pop()  # while结束表示当前节点node为空，即前一个节点没有左子树了\n            node = node.right  # 开始查看它的右子树\n\n    def in_order_stack(self, root):  # 堆栈实现中序遍历（非递归）\n        if not root:\n            return\n        myStack = []\n        node = root\n        while myStack or node:  # 从根节点开始，一直寻找它的左子树\n            while node:\n                myStack.append(node)\n                node = node.left\n            node = myStack.pop()\n            print(node.data),\n            node = node.right\n\n    def post_order_stack(self, root):  # 堆栈实现后序遍历（非递归）\n        # 先遍历根节点，再遍历右子树，最后是左子树，这样就可以转化为和先序遍历一个类型了，最后只把遍历结果逆序输出就OK了。\n        if not root:\n            return\n        myStack1 = []\n        # stack2是为了逆序输出\n        myStack2 = []\n        node = root\n        while myStack1 or node:\n            while node:\n                myStack2.append(node)\n                myStack1.append(node)\n                node = node.right\n            node = myStack1.pop()\n            node = node.left\n        while myStack2:\n            print(myStack2.pop().data),\n    \n\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);