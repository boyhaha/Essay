(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{366:function(v,_,l){v.exports=l.p+"assets/img/cdbdff448158f05c729d8c35086d7414.cdbdff44.jpg"},367:function(v,_,l){v.exports=l.p+"assets/img/1569204872a02cb6d36be960673ddd35.15692048.jpg"},368:function(v,_,l){v.exports=l.p+"assets/img/5526d4828a9c73e16254b343c7b2ebf1.5526d482.jpg"},369:function(v,_,l){v.exports=l.p+"assets/img/cd2ae9e3bd18e974ba7ded9f713962ed.cd2ae9e3.jpg"},370:function(v,_,l){v.exports=l.p+"assets/img/f3a75d73b8c42b726b368133c684a329.f3a75d73.jpg"},371:function(v,_,l){v.exports=l.p+"assets/img/18749f21c876e571e7b22452cf39377f.18749f21.jpg"},461:function(v,_,l){"use strict";l.r(_);var i=l(44),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,i=v._self._c||_;return i("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[i("h1",{attrs:{id:"_60-数据结构"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_60-数据结构"}},[v._v("#")]),v._v(" 60-数据结构")]),v._v(" "),i("p",[i("strong",[v._v("问题")])]),v._v(" "),i("ul",[i("li",[i("p",[i("strong",[v._v("顺序表和链表的区别")])]),v._v(" "),i("ul",[i("li",[v._v("顺序表存储数据，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储\n"),i("ul",[i("li",[v._v("存储空间连续，空间利用率高，但如果之后需要进行扩容，会比较麻烦")]),v._v(" "),i("li",[v._v("时间复杂度来说的话，适合索引查找")])])]),v._v(" "),i("li",[v._v("链表则是什么时候存储数据什么时候申请空间，存储空间是分散的\n"),i("ul",[i("li",[v._v("每次申请一个节点的空间，会产生很多空间碎片，而且每个数据元素携带指针，空间利用率低")]),v._v(" "),i("li",[v._v("时间复杂度来说的话，适合插入，删除，移动")])])])])]),v._v(" "),i("li",[i("p",[i("strong",[v._v("顺序表（Array）")]),v._v("：将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。")])]),v._v(" "),i("li",[i("p",[i("strong",[v._v("链表")]),v._v("：将元素存放在通过链接构造起来的一系列存储块中。")])]),v._v(" "),i("li",[i("p",[v._v("栈")]),v._v(" "),i("ul",[i("li",[v._v("栈：只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运行")]),v._v(" "),i("li",[v._v("栈内存由系统自动分配，")])])]),v._v(" "),i("li",[i("p",[v._v("堆")]),v._v(" "),i("ul",[i("li",[v._v("堆：类似与一棵树")]),v._v(" "),i("li",[v._v("堆内存由语言系统环境管理")])])]),v._v(" "),i("li",[i("p",[v._v("队列：")]),v._v(" "),i("ul",[i("li",[v._v("队列是一种先进先出的（First In First Out）的线性表，简称FIFO。允许插入的一端为队尾，允许删除的一端为队头。")])])])]),v._v(" "),i("p",[i("strong",[v._v("链表")])]),v._v(" "),i("ul",[i("li",[v._v("链表是一种由节点（Node）组成的线性数据集合，每个节点通过指针指向下一个节点。它是一种由节点组成，并能用于表示序列的数据结构。")]),v._v(" "),i("li",[i("strong",[v._v("单链表")]),v._v("：每个节点仅指向下一个节点，最后一个节点指向空（null）")]),v._v(" "),i("li",[i("strong",[v._v("双链表")]),v._v("：每个节点有两个指针p，n。p指向前一个节点，n指向下一个节点；最后一个节点指向空")]),v._v(" "),i("li",[i("strong",[v._v("循环链表")]),v._v("：每个节点指向下一个节点，最后一个节点指向第一个节点")]),v._v(" "),i("li",[v._v("时间复杂度：\n"),i("ul",[i("li",[v._v("索引：O(n)")]),v._v(" "),i("li",[v._v("查找：O(n)")]),v._v(" "),i("li",[v._v("插入：O(1)")]),v._v(" "),i("li",[v._v("删除：O(1)")])])])]),v._v(" "),i("p",[i("strong",[v._v("栈")])]),v._v(" "),i("ul",[i("li",[v._v("栈是一个元素集合，支持两个基本操作：push用于将元素压入栈，pop用于删除栈顶元素。")]),v._v(" "),i("li",[v._v("后进先出的数据结构（Last In First Out, LIFO）")]),v._v(" "),i("li",[v._v("时间复杂度\n"),i("ul",[i("li",[v._v("索引：O(n)")]),v._v(" "),i("li",[v._v("查找：O(n)")]),v._v(" "),i("li",[v._v("插入：O(1)")]),v._v(" "),i("li",[v._v("删除：O(1)")])])])]),v._v(" "),i("p",[i("strong",[v._v("队列")])]),v._v(" "),i("ul",[i("li",[v._v("队列是一个元素集合，支持两种基本操作：enqueue 用于添加一个元素到队列，dequeue 用于删除队列中的一个元素。")]),v._v(" "),i("li",[v._v("先进先出的数据结构（First In First Out, FIFO）。")]),v._v(" "),i("li",[v._v("时间复杂度\n"),i("ul",[i("li",[v._v("索引：O(n)")]),v._v(" "),i("li",[v._v("查找：O(n)")]),v._v(" "),i("li",[v._v("插入：O(1)")]),v._v(" "),i("li",[v._v("删除：O(1)")])])])]),v._v(" "),i("p",[i("strong",[v._v("树")])]),v._v(" "),i("ul",[i("li",[v._v("树是无向、联通的无环图。")])]),v._v(" "),i("p",[i("strong",[v._v("二叉树")])]),v._v(" "),i("ul",[i("li",[v._v("二叉树是一个树形数据结构，每个节点最多可以有两个子节点，称为左子节点和右子节点。")]),v._v(" "),i("li",[v._v("满二叉树（Full Tree）：二叉树中的每个节点有 0 或者 2 个子节点。")]),v._v(" "),i("li",[v._v("完美二叉树（Perfect Binary）：二叉树中的每个节点有两个子节点，并且所有的叶子节点的深度是一样的。")]),v._v(" "),i("li",[v._v("完全二叉树：二叉树中除最后一层外其他各层的节点数均达到最大值，最后一层的节点都连续集中在最左边。")])]),v._v(" "),i("p",[i("strong",[v._v("二叉查找树")])]),v._v(" "),i("ul",[i("li",[v._v("二叉查找树（BST）是一种二叉树。其任何节点的值都大于等于左子树中的值，小于等于右子树中的值。")]),v._v(" "),i("li",[v._v("时间复杂度\n"),i("ul",[i("li",[v._v("索引：O(log(n))")]),v._v(" "),i("li",[v._v("查找：O(log(n))")]),v._v(" "),i("li",[v._v("插入：O(log(n))")]),v._v(" "),i("li",[v._v("删除：O(log(n))")])])])]),v._v(" "),i("p",[i("img",{attrs:{src:l(366),alt:"cdbdff448158f05c729d8c35086d7414.jpe"}})]),v._v(" "),i("p",[i("strong",[v._v("字典树")])]),v._v(" "),i("ul",[i("li",[v._v("字典树，又称为基数树或前缀树，是一种用于存储键值为字符串的动态集合或关联数组的查找树。树中的节点并不直接存储关联键值，而是该节点在树中的位置决定了其关联键值。一个节点的所有子节点都有相同的前缀，根节点则是空字符串。")])]),v._v(" "),i("p",[i("img",{attrs:{src:l(367),alt:"1569204872a02cb6d36be960673ddd35.jpe"}})]),v._v(" "),i("p",[i("strong",[v._v("树状数组")])]),v._v(" "),i("ul",[i("li",[v._v("树状数组，又称为二进制索引树（Binary Indexed Tree，BIT），其概念上是树，但以数组实现。数组中的下标代表树中的节点，每个节点的父节点或子节点的下标可以通过位运算获得。数组中的每个元素都包含了预计算的区间值之和，在整个树更新的过程中，这些计算的值也同样会被更新。")]),v._v(" "),i("li",[v._v("时间复杂度\n"),i("ul",[i("li",[v._v("区间求和：O(log(n))")]),v._v(" "),i("li",[v._v("更新：O(log(n))")])])])]),v._v(" "),i("p",[i("img",{attrs:{src:l(368),alt:"5526d4828a9c73e16254b343c7b2ebf1.jpe"}})]),v._v(" "),i("p",[i("strong",[v._v("线段树")])]),v._v(" "),i("ul",[i("li",[v._v("线段树是用于存储区间和线段的树形数据结构。它允许查找一个节点在若干条线段中出现的次数。")]),v._v(" "),i("li",[v._v("时间复杂度\n"),i("ul",[i("li",[v._v("区间查找：O(log(n))")]),v._v(" "),i("li",[v._v("更新：O(log(n))")])])])]),v._v(" "),i("p",[i("img",{attrs:{src:l(369),alt:"cd2ae9e3bd18e974ba7ded9f713962ed.jpe"}})]),v._v(" "),i("p",[i("strong",[v._v("堆")])]),v._v(" "),i("ul",[i("li",[v._v("堆是一种基于树的满足某些特性的数据结构：整个堆中的所有父子节点的键值都满足相同的排序条件。堆分为最大堆和最小堆。在最大堆中，父节点的键值永远大于等于所有子节点的键值，根节点的键值是最大的。最小堆中，父节点的键值永远小于等于所有子节点的键值，根节点的键值是最小的。")]),v._v(" "),i("li",[v._v("时间复杂度\n"),i("ul",[i("li",[v._v("索引：O(log(n))")]),v._v(" "),i("li",[v._v("查找：O(log(n))")]),v._v(" "),i("li",[v._v("插入：O(log(n))")]),v._v(" "),i("li",[v._v("删除：O(log(n))")]),v._v(" "),i("li",[v._v("删除最大值/最小值：O(1)")])])])]),v._v(" "),i("p",[i("strong",[v._v("哈希")])]),v._v(" "),i("ul",[i("li",[v._v("哈希用于将任意长度的数据映射到固定长度的数据。哈希函数的返回值被称为哈希值、哈希码或者哈希。如果不同的主键得到相同的哈希值，则发生了冲突。")]),v._v(" "),i("li",[i("strong",[v._v("Hash Map")]),v._v("：是一个存储键值间关系的数据结构。HashMap 通过哈希函数将键转化为桶或者槽中的下标，从而便于指定值的查找。")]),v._v(" "),i("li",[v._v("冲突解决\n"),i("ul",[i("li",[v._v("链地址法（Separate Chaining）：在链地址法中，每个桶（bucket）是相互独立的，每一个索引对应一个元素列表。处理HashMap 的时间就是查找桶的时间（常量）与遍历列表元素的时间之和。")]),v._v(" "),i("li",[v._v("开放地址法（Open Addressing）：在开放地址方法中，当插入新值时，会判断该值对应的哈希桶是否存在，如果存在则根据某种算法依次选择下一个可能的位置，直到找到一个未被占用的地址。开放地址即某个元素的位置并不永远由其哈希值决定")])])])]),v._v(" "),i("p",[i("img",{attrs:{src:l(370),alt:"f3a75d73b8c42b726b368133c684a329.jpe"}})]),v._v(" "),i("p",[i("strong",[v._v("图")])]),v._v(" "),i("ul",[i("li",[v._v("图是G =（V，E）的有序对，其包括顶点或节点的集合 V 以及边或弧的集合E，其中E包括了两个来自V的元素（即边与两个顶点相关联 ，并且该关联为这两个顶点的无序对）。\n"),i("ul",[i("li",[v._v("无向图：图的邻接矩阵是对称的，因此如果存在节点 u 到节点 v 的边，那节点 v 到节点 u 的边也一定存在。")]),v._v(" "),i("li",[v._v("有向图：图的邻接矩阵不是对称的。因此如果存在节点 u 到节点 v 的边并不意味着一定存在节点 v 到节点 u 的边")])])])]),v._v(" "),i("p",[i("img",{attrs:{src:l(371),alt:"18749f21c876e571e7b22452cf39377f.jpe"}})])])}),[],!1,null,null,null);_.default=t.exports}}]);