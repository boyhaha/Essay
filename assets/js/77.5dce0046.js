(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{443:function(_,v,l){"use strict";l.r(v);var i=l(44),t=Object(i.a)({},(function(){var _=this,v=_.$createElement,l=_._self._c||v;return l("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[l("h1",{attrs:{id:"_60-数据结构"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_60-数据结构"}},[_._v("#")]),_._v(" 60-数据结构")]),_._v(" "),l("p",[l("strong",[_._v("问题")])]),_._v(" "),l("ul",[l("li",[l("p",[l("strong",[_._v("顺序表和链表的区别")])]),_._v(" "),l("ul",[l("li",[_._v("顺序表存储数据，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储\n"),l("ul",[l("li",[_._v("存储空间连续，空间利用率高，但")]),_._v(" "),l("li",[_._v("时间复杂度来说的话，适合索引查找")])])]),_._v(" "),l("li",[_._v("链表则是什么时候存储数据什么时候申请空间，存储空间是分散的\n"),l("ul",[l("li",[_._v("每次申请一个节点的空间，会产生很多空间碎片，而且每个数据元素携带指针，空间利用率低")]),_._v(" "),l("li",[_._v("时间复杂度来说的话，适合插入，删除，移动")])])])])]),_._v(" "),l("li",[l("p",[l("strong",[_._v("顺序表（Array）")])])]),_._v(" "),l("li",[l("p",[l("strong",[_._v("链表")])])]),_._v(" "),l("li",[l("p",[_._v("栈")]),_._v(" "),l("ul",[l("li",[_._v("栈：只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运行")]),_._v(" "),l("li",[_._v("栈内存由系统自动分配，")])])]),_._v(" "),l("li",[l("p",[_._v("堆")]),_._v(" "),l("ul",[l("li",[_._v("堆：类似与一棵树")]),_._v(" "),l("li",[_._v("堆内存由语言系统环境管理")])])]),_._v(" "),l("li",[l("p",[_._v("队列：")]),_._v(" "),l("ul",[l("li",[_._v("队列是一种先进先出的（First In First Out）的线性表，简称FIFO。允许插入的一端为队尾，允许删除的一端为队头。")])])])]),_._v(" "),l("p",[l("strong",[_._v("链表")])]),_._v(" "),l("ul",[l("li",[_._v("链表是一种由节点（Node）组成的线性数据集合，每个节点通过指针指向下一个节点。它是一种由节点组成，并能用于表示序列的数据结构。")]),_._v(" "),l("li",[l("strong",[_._v("单链表")])]),_._v(" "),l("li",[l("strong",[_._v("双链表")])]),_._v(" "),l("li",[l("strong",[_._v("循环链表")])]),_._v(" "),l("li",[_._v("时间复杂度：\n"),l("ul",[l("li",[_._v("索引：O(n)")]),_._v(" "),l("li",[_._v("查找：O(n)")]),_._v(" "),l("li",[_._v("插入：O(1)")]),_._v(" "),l("li",[_._v("删除：O(1)")])])])]),_._v(" "),l("p",[l("strong",[_._v("栈")])]),_._v(" "),l("ul",[l("li",[_._v("栈是一个元素集合，支持两个基本操作：push用于将元素压入栈，pop用于删除栈顶元素。")]),_._v(" "),l("li",[_._v("后进先出的数据结构（Last In First Out, LIFO）")]),_._v(" "),l("li",[_._v("时间复杂度\n"),l("ul",[l("li",[_._v("索引：O(n)")]),_._v(" "),l("li",[_._v("查找：O(n)")]),_._v(" "),l("li",[_._v("插入：O(1)")]),_._v(" "),l("li",[_._v("删除：O(1)")])])])]),_._v(" "),l("p",[l("strong",[_._v("队列")])]),_._v(" "),l("ul",[l("li",[_._v("队列是一个元素集合，支持两种基本操作：enqueue 用于添加一个元素到队列，dequeue 用于删除队列中的一个元素。")]),_._v(" "),l("li",[_._v("先进先出的数据结构（First In First Out, FIFO）。")]),_._v(" "),l("li",[_._v("时间复杂度\n"),l("ul",[l("li",[_._v("索引：O(n)")]),_._v(" "),l("li",[_._v("查找：O(n)")]),_._v(" "),l("li",[_._v("插入：O(1)")]),_._v(" "),l("li",[_._v("删除：O(1)")])])])]),_._v(" "),l("p",[l("strong",[_._v("树")])]),_._v(" "),l("ul",[l("li",[_._v("树是无向、联通的无环图。")])]),_._v(" "),l("p",[l("strong",[_._v("二叉树")])]),_._v(" "),l("ul",[l("li",[_._v("二叉树是一个树形数据结构，每个节点最多可以有两个子节点，称为左子节点和右子节点。")]),_._v(" "),l("li",[l("strong",[_._v("满二叉树（Full Tree）")])]),_._v(" "),l("li",[l("strong",[_._v("完美二叉树（Perfect Binary）")])]),_._v(" "),l("li",[l("strong",[_._v("完全二叉树")])])]),_._v(" "),l("p",[l("strong",[_._v("二叉查找树")])]),_._v(" "),l("ul",[l("li",[_._v("二叉查找树（BST）是一种二叉树。其任何节点的值都大于等于左子树中的值，小于等于右子树中的值。")]),_._v(" "),l("li",[_._v("时间复杂度\n"),l("ul",[l("li",[_._v("索引：O(log(n))")]),_._v(" "),l("li",[_._v("查找：O(log(n))")]),_._v(" "),l("li",[_._v("插入：O(log(n))")]),_._v(" "),l("li",[_._v("删除：O(log(n))")])])])]),_._v(" "),l("p",[l("img",{attrs:{src:"image/cdbdff448158f05c729d8c35086d7414.jpe",alt:"cdbdff448158f05c729d8c35086d7414.jpe"}})]),_._v(" "),l("p",[l("strong",[_._v("字典树")])]),_._v(" "),l("ul",[l("li",[_._v("字典树，又称为基数树或前缀树，是一种用于存储键值为字符串的动态集合或关联数组的查找树。树中的节点并不直接存储关联键值，而是该节点在树中的位置决定了其关联键值。一个节点的所有子节点都有相同的前缀，根节点则是空字符串。")])]),_._v(" "),l("p",[l("img",{attrs:{src:"image/1569204872a02cb6d36be960673ddd35.jpe",alt:"1569204872a02cb6d36be960673ddd35.jpe"}})]),_._v(" "),l("p",[l("strong",[_._v("树状数组")])]),_._v(" "),l("ul",[l("li",[_._v("树状数组，又称为二进制索引树（Binary Indexed Tree，BIT），其概念上是树，但以数组实现。数组中的下标代表树中的节点，每个节点的父节点或子节点的下标可以通过位运算获得。数组中的每个元素都包含了预计算的区间值之和，在整个树更新的过程中，这些计算的值也同样会被更新。")]),_._v(" "),l("li",[_._v("时间复杂度\n"),l("ul",[l("li",[_._v("区间求和：O(log(n))")]),_._v(" "),l("li",[_._v("更新：O(log(n))")])])])]),_._v(" "),l("p",[l("img",{attrs:{src:"image/5526d4828a9c73e16254b343c7b2ebf1.jpe",alt:"5526d4828a9c73e16254b343c7b2ebf1.jpe"}})]),_._v(" "),l("p",[l("strong",[_._v("线段树")])]),_._v(" "),l("ul",[l("li",[_._v("线段树是用于存储区间和线段的树形数据结构。它允许查找一个节点在若干条线段中出现的次数。")]),_._v(" "),l("li",[_._v("时间复杂度\n"),l("ul",[l("li",[_._v("区间查找：O(log(n))")]),_._v(" "),l("li",[_._v("更新：O(log(n))")])])])]),_._v(" "),l("p",[l("img",{attrs:{src:"image/cd2ae9e3bd18e974ba7ded9f713962ed.jpe",alt:"cd2ae9e3bd18e974ba7ded9f713962ed.jpe"}})]),_._v(" "),l("p",[l("strong",[_._v("堆")])]),_._v(" "),l("ul",[l("li",[_._v("堆是一种基于树的满足某些特性的数据结构：整个堆中的所有父子节点的键值都满足相同的排序条件。堆分为最大堆和最小堆。在最大堆中，父节点的键值永远大于等于所有子节点的键值，根节点的键值是最大的。最小堆中，父节点的键值永远小于等于所有子节点的键值，根节点的键值是最小的。")]),_._v(" "),l("li",[_._v("时间复杂度\n"),l("ul",[l("li",[_._v("索引：O(log(n))")]),_._v(" "),l("li",[_._v("查找：O(log(n))")]),_._v(" "),l("li",[_._v("插入：O(log(n))")]),_._v(" "),l("li",[_._v("删除：O(log(n))")]),_._v(" "),l("li",[_._v("删除最大值/最小值：O(1)")])])])]),_._v(" "),l("p",[l("img",{attrs:{src:"image/f830e26d538722d65e04eafba99572cd.jpe",alt:"f830e26d538722d65e04eafba99572cd.jpe"}})]),_._v(" "),l("p",[l("strong",[_._v("哈希")])]),_._v(" "),l("ul",[l("li",[_._v("哈希用于将任意长度的数据映射到固定长度的数据。哈希函数的返回值被称为哈希值、哈希码或者哈希。如果不同的主键得到相同的哈希值，则发生了冲突。")]),_._v(" "),l("li",[l("strong",[_._v("Hash Map")])]),_._v(" "),l("li",[_._v("冲突解决\n"),l("ul",[l("li",[l("strong",[_._v("链地址法（")])]),_._v(" "),l("li",[l("strong",[_._v("开放地址法（")])])])])]),_._v(" "),l("p",[l("img",{attrs:{src:"image/f3a75d73b8c42b726b368133c684a329.jpe",alt:"f3a75d73b8c42b726b368133c684a329.jpe"}})]),_._v(" "),l("p",[l("strong",[_._v("图")])]),_._v(" "),l("ul",[l("li",[_._v("图是G =（V，E）的有序对，其包括顶点或节点的集合 V 以及边或弧的集合E，其中E包括了两个来自V的元素（即边与两个顶点相关联 ，并且该关联为这两个顶点的无序对）。")]),_._v(" "),l("li",[l("strong",[_._v("无向图")])]),_._v(" "),l("li",[l("strong",[_._v("有向图")])])]),_._v(" "),l("p",[l("img",{attrs:{src:"image/18749f21c876e571e7b22452cf39377f.jpe",alt:"18749f21c876e571e7b22452cf39377f.jpe"}})])])}),[],!1,null,null,null);v.default=t.exports}}]);