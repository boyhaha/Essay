(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{418:function(_,a,t){"use strict";t.r(a);var v=t(44),e=Object(v.a)({},(function(){var _=this,a=_.$createElement,t=_._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"_08-异步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_08-异步"}},[_._v("#")]),_._v(" 08-异步")]),_._v(" "),t("h2",{attrs:{id:"深入理解python异步编程-上-原文链接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深入理解python异步编程-上-原文链接"}},[_._v("#")]),_._v(" 深入理解Python异步编程(上)原文链接：")]),_._v(" "),t("h2",{attrs:{id:"https-mp-weixin-qq-com-s-biz-mzixmjy5nte0ma-mid-2247483720-idx-1-sn-f016c06ddd17765fd50b705fed64429c"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https-mp-weixin-qq-com-s-biz-mzixmjy5nte0ma-mid-2247483720-idx-1-sn-f016c06ddd17765fd50b705fed64429c"}},[_._v("#")]),_._v(" "),t("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzIxMjY5NTE0MA==&mid=2247483720&idx=1&sn=f016c06ddd17765fd50b705fed64429c",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://mp.weixin.qq.com/s?__biz=MzIxMjY5NTE0MA==&mid=2247483720&idx=1&sn=f016c06ddd17765fd50b705fed64429c"),t("OutboundLink")],1)]),_._v(" "),t("ul",[t("li",[_._v("2013年起由 Python 之父 Guido 亲自操刀主持了Tulip(asyncio)项目的开发")])]),_._v(" "),t("ol",[t("li",[_._v("概念\n"),t("ul",[t("li",[_._v("并行\n"),t("ul",[t("li",[_._v("是为了利用多核加速多任务完成的进度")])])]),_._v(" "),t("li",[_._v("并发\n"),t("ul",[t("li",[_._v("是为了让独立的子任务都有机会被尽快执行，但不一定能加速整体进度")])])]),_._v(" "),t("li",[_._v("非阻塞\n"),t("ul",[t("li",[_._v("是为了提高程序整体执行效率")])])]),_._v(" "),t("li",[_._v("异步\n"),t("ul",[t("li",[_._v("是高效地组织非阻塞任务的方式")])])]),_._v(" "),t("li",[_._v("要支持并发，必须拆分为多任务，不同任务相对而言才有阻塞/非阻塞、同步/异步。所以，并发、异步、非阻塞三个词总是如影随形。")]),_._v(" "),t("li",[t("span",{staticStyle:{"background-color":"#ffaaaa"}},[_._v("异步")]),_._v(" "),t("ul",[t("li",[_._v("以进程，线程，协程，函数/方法作为执行任务程序的基本单位，结合回调，事件循环，信号量等机制，以提高程序整体执行效率和并发能力的编程方式")]),_._v(" "),t("li",[_._v("同步和异步的显著区别：\n"),t("ul",[t("li",[_._v("有序和无序")])])])])]),_._v(" "),t("li",[_._v("同步与异步\n"),t("ul",[t("li",[t("strong",[_._v("同步")])]),_._v(" "),t("li",[t("strong",[_._v("异步")])]),_._v(" "),t("li",[_._v("区别就在于一个需要等待，一个不需要等待")])])])])]),_._v(" "),t("li",[_._v("面临问题\n"),t("ul",[t("li",[_._v("成本和效率")]),_._v(" "),t("li",[_._v("C10k/C10M挑战\n"),t("ul",[t("li",[_._v("从技术角度挑战软硬件极限")])])]),_._v(" "),t("li",[_._v("解决方案\n"),t("ul",[t("li",[_._v("I/O（")]),_._v(" "),t("li",[t("span",{staticStyle:{"background-color":"#ffaaaa"}},[_._v("异步编程")])])])])])]),_._v(" "),t("li",[_._v("异步I/O进化之路\n"),t("ul",[t("li",[_._v("网络I/O是目前最大的I/O瓶颈，诸多")]),_._v(" "),t("li",[_._v("以爬虫为例，从因特网下载十片文章\n"),t("ul",[t("li",[_._v("同步阻塞方式\n"),t("ul",[t("li",[_._v("依次下载，")]),_._v(" "),t("li",[_._v("效率低下")])])]),_._v(" "),t("li",[_._v("多进程\n"),t("ul",[t("li",[_._v("开10个进程执行")]),_._v(" "),t("li",[_._v("切换开销大，支持规模小（数十到数百）")])])]),_._v(" "),t("li",[_._v("多线程\n"),t("ul",[t("li",[_._v("线程的数据结构比进程更轻量级，同一个进程可以容纳多个线程")]),_._v(" "),t("li",[_._v("支持规模不够大（数百个到数千个）")]),_._v(" "),t("li",[_._v("主要问题： 竞态条件（无序，需要锁或者同步队列来保证下载顺序不会重复执行）")])])]),_._v(" "),t("li",[_._v("非阻塞方式\n"),t("ul",[t("li",[_._v("原始")]),_._v(" "),t("li",[_._v("改进\n"),t("ul",[t("li",[_._v("epoll（linux）")]),_._v(" "),t("li",[_._v("回调（callback）")]),_._v(" "),t("li",[_._v("事件循环（\n"),t("ul",[t("li",[_._v("等待事件通知的循环")]),_._v(" "),t("li",[_._v("可以算作异步编程")]),_._v(" "),t("li",[_._v("支持规模达到（")]),_._v(" "),t("li",[_._v("问题：\n"),t("ul",[t("li",[_._v("回调层次过多时代码可读性差")]),_._v(" "),t("li",[_._v("破坏代码结构")]),_._v(" "),t("li",[_._v("共享状态管理困难")]),_._v(" "),t("li",[_._v("错误处理困难")])])])])])])])])])])])])]),_._v(" "),t("li",[_._v("Python对异步I/O的优化\n"),t("ul",[t("li",[_._v("回调之痛，以始为终\n"),t("ul",[t("li",[_._v("在")]),_._v(" "),t("li",[_._v("代表作有 Tornado、Twisted、asyncio 等")])])]),_._v(" "),t("li",[_._v("协程（")])])])]),_._v(" "),t("h1",{attrs:{id:"asyncio"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#asyncio"}},[_._v("#")]),_._v(" "),t("a",{attrs:{href:"https://www.lylinux.net/article/2019/6/9/57.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("asyncio"),t("OutboundLink")],1)]),_._v(" "),t("ul",[t("li",[_._v("asyncio")])]),_._v(" "),t("p",[t("strong",[_._v("import")]),_._v(" threading")]),_._v(" "),t("p",[t("strong",[_._v("import")]),_._v(" asyncio")]),_._v(" "),t("p",[_._v("@asyncio.coroutine")]),_._v(" "),t("p",[t("strong",[_._v("def")]),_._v(" "),t("strong",[_._v("hello")]),_._v("():")]),_._v(" "),t("p",[_._v("print('Hello world! (%s)' % threading.currentThread())")]),_._v(" "),t("p",[_._v("**    yield** "),t("strong",[_._v("from")]),_._v(" asyncio.sleep(1)")]),_._v(" "),t("p",[_._v("print('Hello again! (%s)' % threading.currentThread())")]),_._v(" "),t("p",[_._v("loop = asyncio.get_event_loop()")]),_._v(" "),t("p",[_._v("tasks = [hello(), hello()]")]),_._v(" "),t("p",[_._v("loop.run_until_complete(asyncio.wait(tasks))")]),_._v(" "),t("p",[_._v("loop.close()")]),_._v(" "),t("p",[_._v("如果把asyncio.sleep()换成真正的IO操作，则多个coroutine就可以由一个线程并发执行。")]),_._v(" "),t("p",[t("span",{staticStyle:{"background-color":"#ffaaaa"}},[t("span",{staticStyle:{"background-color":"#ffaaaa"}},[_._v("可以用单线程+")]),t("span",{staticStyle:{"background-color":"#ffaaaa"}},[_._v("coroutine")]),t("span",{staticStyle:{"background-color":"#ffaaaa"}},[_._v("实现多用户的高并发支持。")])])]),_._v(" "),t("ul",[t("li",[_._v("async / await")]),_._v(" "),t("li",[_._v("asyncio")])]),_._v(" "),t("h2",{attrs:{id:"asyncio中的基本概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#asyncio中的基本概念"}},[_._v("#")]),_._v(" asyncio中的基本概念")]),_._v(" "),t("p",[_._v("可以看见，使用asyncio库我们也可以在python代码中使用async和await。在asyncio中，有四个基本概念，分别是：")]),_._v(" "),t("h3",{attrs:{id:"eventloop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#eventloop"}},[_._v("#")]),_._v(" Eventloop")]),_._v(" "),t("p",[_._v("Eventloop可以说是asyncio应用的核心，中央总控，Eventloop实例提供了注册、取消、执行任务和回调 的方法。 简单来说，就是我们可以把一些异步函数注册到这个事件循环上，事件循环回循环执行这些函数（每次只能执行一个），如果当前正在执行的函数在等待I/O返回，那么事件循环就会暂停它的执行去执行其他函数。当某个函数完成I/O后会恢复，等到下次循环到它的时候就会继续执行。")]),_._v(" "),t("h3",{attrs:{id:"coroutine"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#coroutine"}},[_._v("#")]),_._v(" Coroutine")]),_._v(" "),t("p",[_._v("协程本质就是一个函数，")]),_._v(" "),t("h3",{attrs:{id:"future"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#future"}},[_._v("#")]),_._v(" Future")]),_._v(" "),t("p",[_._v("Future是表示一个“未来”对象，类似于javascript中的promise，当异步操作结束后会把最终结果设置到这个Future对象上，Future是对协程的封装。")]),_._v(" "),t("h3",{attrs:{id:"task"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#task"}},[_._v("#")]),_._v(" Task")]),_._v(" "),t("p",[_._v("Eventloop除了支持协程，还支持注册Future和Task2种类型的对象，而Future是协程的封装，Future对象提供了很多任务方法（如完成后的回调，取消，设置任务结果等等），但是一般情况下开发者不需要操作Future这种底层对象，而是直接用Future的子类Task协同的调度协程来实现并发。那么什么是Task呢？下面介绍下：")]),_._v(" "),t("p",[_._v("_ 一个与__Future__类似的对象，可运行__Python__协程。非线程安全。�_�_Task__对象被用来在事件循环中运行协程。如果一个协程在等待一个__Future__对象，"),t("strong",[_._v("Task__对象会挂起该协程的执行并等待该__Future__对象完成。当该__Future__对象完成被打包的协程将恢复执行。 事件循环使用协同日程调度: 一个事件循环每次运行一个__Task__对象。而一个__Task__对象会等待一个__Future__对象完成，该事件循环会运行其他__Task")]),_._v("、回调或执行IO操作。_")]),_._v(" "),t("h2",{attrs:{id:""}},[t("a",{staticClass:"header-anchor",attrs:{href:"#"}},[_._v("#")])]),_._v(" "),t("h2",{attrs:{id:"asyncio中一些常见用法的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#asyncio中一些常见用法的区别"}},[_._v("#")]),_._v(" asyncio中一些常见用法的区别")]),_._v(" "),t("h3",{attrs:{id:"asyncio-gather和asyncio-wait"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#asyncio-gather和asyncio-wait"}},[_._v("#")]),_._v(" Asyncio.gather和asyncio.wait")]),_._v(" "),t("ol",[t("li",[_._v("asyncio.gather")]),_._v(" "),t("li",[_._v("asyncio.wait")])]),_._v(" "),t("h3",{attrs:{id:"asyncio-create-task和loop-create-task以及asyncio-ensure-future"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#asyncio-create-task和loop-create-task以及asyncio-ensure-future"}},[_._v("#")]),_._v(" asyncio.create_task和loop.create_task以及asyncio.ensure_future")]),_._v(" "),t("p",[_._v("这三种方法都可以创建Task,从Python3.7开始可以统一的使用更高阶的asyncio.create_task.其实asyncio.create_task就是用的loop.create_task. loop.create_task接受的参数需要是一个协程，但是asyncio.ensure_future除了接受协程，还可以是Future对象或者awaitable对象：")]),_._v(" "),t("ol",[t("li",[_._v("如果参数是协程，其底层使用")]),_._v(" "),t("li",[_._v("如果是")]),_._v(" "),t("li",[_._v("如果是一个")])]),_._v(" "),t("p",[_._v("所以ensure_future方法主要就是确保这是一个Future对象，一般情况下直接用asyncio.create_task就可以了。")]),_._v(" "),t("h3",{attrs:{id:"注册回调和执行同步代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注册回调和执行同步代码"}},[_._v("#")]),_._v(" 注册回调和执行同步代码")]),_._v(" "),t("p",[_._v("可以使用add_done_callback来添加成功回调：")]),_._v(" "),t("p",[_._v("def callback(future):")]),_._v(" "),t("p",[_._v("print(f'Result: {future.result()}')")]),_._v(" "),t("p",[_._v("def callback2(future, n):")]),_._v(" "),t("p",[_._v("print(f'Result: {future.result()}, N: {n}')")]),_._v(" "),t("p",[_._v("async def funa():")]),_._v(" "),t("p",[_._v("await asyncio.sleep(1)")]),_._v(" "),t("p",[_._v('return "funa"')]),_._v(" "),t("p",[_._v("async def main():")]),_._v(" "),t("p",[_._v("task = asyncio.create_task(funa())")]),_._v(" "),t("p",[_._v("task.add_done_callback(callback)")]),_._v(" "),t("p",[_._v("await task")]),_._v(" "),t("p",[_._v("#这样可以为callback传递参数")]),_._v(" "),t("p",[_._v("task = asyncio.create_task(funa())")]),_._v(" "),t("p",[_._v("task.add_done_callback(functools.partial(callback2, n=1))")]),_._v(" "),t("p",[_._v("await task")]),_._v(" "),t("p",[_._v("if __name__ == '__main__':")]),_._v(" "),t("p",[_._v("asyncio.run(main())")]),_._v(" "),t("h4",{attrs:{id:"执行同步代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行同步代码"}},[_._v("#")]),_._v(" 执行同步代码")]),_._v(" "),t("p",[_._v("如果有同步逻辑，想要用asyncio来实现并发，那么需要怎么做呢？下面看看：")]),_._v(" "),t("p",[_._v("def a1():")]),_._v(" "),t("p",[_._v("time.sleep(1)")]),_._v(" "),t("p",[_._v('return "A"')]),_._v(" "),t("p",[_._v("async def b1():")]),_._v(" "),t("p",[_._v("await asyncio.sleep(1)")]),_._v(" "),t("p",[_._v('return "B"')]),_._v(" "),t("p",[_._v("async def main():")]),_._v(" "),t("p",[_._v("loop = asyncio.get_running_loop()")]),_._v(" "),t("p",[_._v("await asyncio.gather(loop.run_in_executor(None, a1), b1())")]),_._v(" "),t("p",[_._v("if __name__ == '__main__':")]),_._v(" "),t("p",[_._v("start = time.perf_counter()")]),_._v(" "),t("p",[_._v("asyncio.run(main())")]),_._v(" "),t("p",[_._v("print(f'main method Cost: {time.perf_counter() - start}')")]),_._v(" "),t("p",[_._v("# 输出： main method Cost: 1.0050589740000002")]),_._v(" "),t("p",[_._v("可以使用run_into_executor来将同步函数逻辑转化成一个协程，第一个参数是要传递concurrent.futures.Executor实例的，传递None会选择默认的executor。")])])}),[],!1,null,null,null);a.default=e.exports}}]);