(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{466:function(e,n,s){"use strict";s.r(n);var t=s(44),l=Object(t.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"_63-图相关"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_63-图相关"}},[e._v("#")]),e._v(" 63-图相关")]),e._v(" "),s("ol",[s("li",[e._v("回溯法(探索与回溯法)是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。\n首先有一个概念：回溯")])]),e._v(" "),s("ul",[s("li",[e._v("（1）访问初始顶点v并标记顶点v已访问。\n（2）查找顶点v的第一个邻接顶点w。\n（3）若顶点v的邻接顶点w存在，则继续执行；否则回溯到v，再找v的另外一个未访问过的邻接点。\n（4）若顶点w尚未被访问，则访问顶点w并标记顶点w为已访问。\n（5）继续查找顶点w的下一个邻接顶点wi，如果v取值wi转到步骤（3）。直到连通图中所有顶点全部访问过为止。\n"),s("img",{attrs:{src:"image/80c4e190a796511b6f4551807005af2c.png",alt:"80c4e190a796511b6f4551807005af2c.png"}}),e._v("\n深度优先算法：")]),e._v(" "),s("li",[e._v("（1）顶点v入队列。\n（2）当队列非空时则继续执行，否则算法结束。\n（3）出队列取得队头顶点v；访问顶点v并标记顶点v已被访问。\n（4）查找顶点v的第一个邻接顶点col。\n（5）若v的邻接顶点col未被访问过的，则col入队列。\n（6）继续查找顶点v的另一个新的邻接顶点col，转到步骤（5）。\n直到顶点v的所有未被访问过的邻接点处理完。转到步骤（2）。\n"),s("img",{attrs:{src:"image/81ab855fda031955d8b07d8117058219.png",alt:"81ab855fda031955d8b07d8117058219.png"}}),e._v("\n广度优先算法：")])]),e._v(" "),s("h4",{attrs:{id:"代码实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码实现"}},[e._v("#")]),e._v(" 代码实现")]),e._v(" "),s("ul",[s("li",[e._v("图结构")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Graph:\n    class Vertex:\n        __slots__='_element'\n        def __init__(self,x):\n            self._element = x\n        def element(self):\n            return self._element\n        def __hash__(self):\n            return hash(id(self))\n    class Edge:\n        __slots__='_origin','_destination','_element'\n        def __init__(self,u,v,x):\n            self._origin =u\n            self._destination=v\n            self._element=x\n        def endpoints(self): # 返回元组（u,v）\n            return (self._origin,self._destination)\n        def opposite(self,v):\n            return self._destination if v is self._origin else self._origin\n        def element(self):\n            return self._element\n        def __hash__(self):\n            return hash(self._origin,self._destination)\n            \n    def __init__(self,directed=False):\n        self._outgoing = {}\n        self._incoming = {} if directed else self._outgoing # 只有在有向图的时候激活\n    def is_directed(self):\n        return self._incoming is not self._outgoing\n    def vertex_count(self):\n        return len(self._outgoing)\n    def vertices(self):\n        return self._outgoing.keys()\n    def edge_count(self):\n        total = sum(len(self._outgoing[v]) for v in self._outgoing)\n        return total if self.is_directed() else total//2 # 有向图边是无向图的两倍\n    def edges(self):\n        result =set()\n        for secondary_map in self._outgoing.values():\n            result.update(secondary_map.values) # The A.update(B) adds elements from the set B to A.\n        return result\n    def get_edge(self,u,v):\n        return self._outgoing[u].get(v)\n    def degree(self,v,outgoing=True):\n        adj = self._outgoing if outgoing else self._incoming\n        return len(adj[v])\n    def incident_edges(self,v,outgoing=True):\n        adj=self._outgoing if outgoing else self._incoming\n        for edge in adj[v].values():\n            yield edge\n    def insert_vertex(self,x=None):\n        v=self.Vertex(x)\n        self._outgoing[v]={}\n        if self.is_directed():\n            self._incoming[v]={}\n        return v\n    def insert_edge(self,u,v,x=None):\n        e = self.Edge(u,v,x)\n        self._outgoing[u][v]=e\n        self._incoming[v][u]=e\n* 深度遍历与广度遍历\n# 深度遍历\ndef DFS(g,u,discovered):\n    for e in g.incident_edges(): # for every outgoing edge from u\n        v= e.opposite(u)\n        if v not in discovered:\n            discovered[v]=e\n            DFS(g,v,discovered)\n# 广度遍历\ndef BFS(g,s,discovered):\n    level=[s]\n    while len(level)>0:\n        next_level=[]\n        for u in level:\n            for e in g.incident_edges(u):\n                v = e.opposite(u)\n                if v not in discovered:\n                    discovered[v]=e\n                    next_level.append(v)\n        level=next_level\n\n")])])])])}),[],!1,null,null,null);n.default=l.exports}}]);