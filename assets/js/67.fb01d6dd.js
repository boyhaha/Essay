(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{438:function(a,t,n){"use strict";n.r(t);var s=n(44),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"_08-异步"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_08-异步"}},[a._v("#")]),a._v(" 08-异步")]),a._v(" "),n("h2",{attrs:{id:"深入理解python异步编程-上"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#深入理解python异步编程-上"}},[a._v("#")]),a._v(" "),n("a",{attrs:{href:"!https://mp.weixin.qq.com/s?__biz=MzIxMjY5NTE0MA==&mid=2247483720&idx=1&sn=f016c06ddd17765fd50b705fed64429c"}},[a._v("深入理解Python异步编程(上)")])]),a._v(" "),n("ul",[n("li",[a._v("2013年起由 Python 之父 Guido 亲自操刀主持了Tulip(asyncio)项目的开发")])]),a._v(" "),n("ol",[n("li",[n("p",[a._v("概念")]),a._v(" "),n("ul",[n("li",[a._v("并行\n"),n("ul",[n("li",[a._v("是为了利用多核加速多任务完成的进度")])])]),a._v(" "),n("li",[a._v("并发\n"),n("ul",[n("li",[a._v("是为了让独立的子任务都有机会被尽快执行，但不一定能加速整体进度")])])]),a._v(" "),n("li",[a._v("非阻塞\n"),n("ul",[n("li",[a._v("如果不能立刻得到结果，则该调用者不会阻塞当前线程")]),a._v(" "),n("li",[a._v("是为了提高程序整体执行效率")])])]),a._v(" "),n("li",[a._v("异步\n"),n("ul",[n("li",[a._v("是高效地组织非阻塞任务的方式")])])]),a._v(" "),n("li",[a._v("要支持并发，必须拆分为多任务，不同任务相对而言才有阻塞/非阻塞、同步/异步。所以，并发、异步、非阻塞三个词总是如影随形。")]),a._v(" "),n("li",[n("span",{staticStyle:{"background-color":"#ffaaaa"}},[a._v("异步")]),a._v(" "),n("ul",[n("li",[a._v("以进程，线程，协程，函数/方法作为执行任务程序的基本单位，结合回调，事件循环，信号量等机制，以提高程序整体执行效率和并发能力的编程方式")]),a._v(" "),n("li",[a._v("同步和异步的显著区别：\n"),n("ul",[n("li",[a._v("有序和无序")])])])])]),a._v(" "),n("li",[a._v("同步与异步\n"),n("ul",[n("li",[n("strong",[a._v("同步")]),a._v("就是整个处理过程顺序执行，当各个过程都执行完毕，并返回结果。是一种线性执行的方式，执行的流程不能跨越。一般用于流程性比较强的程序，比如用户登录，需要对用户验证完成后才能登录系统。")]),a._v(" "),n("li",[n("strong",[a._v("异步")]),a._v("则是只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕；而是继续执行下面的流程。是一种并行处理的方式，不必等待一个程序执行完，可以执行其它的任务，比如页面数据加载过程，不需要等所有数据获取后再显示页面。")]),a._v(" "),n("li",[a._v("区别就在于一个需要等待，一个不需要等待")])])])])]),a._v(" "),n("li",[n("p",[a._v("面临问题")]),a._v(" "),n("ul",[n("li",[a._v("成本和效率")]),a._v(" "),n("li",[a._v("C10k/C10M挑战\n"),n("ul",[n("li",[a._v("从技术角度挑战软硬件极限")])])]),a._v(" "),n("li",[a._v("解决方案\n"),n("ul",[n("li",[a._v("“除了瓶颈之外，任何改进都是幻觉。”  ------- 《约束理论与企业优化》")]),a._v(" "),n("li",[a._v("I/O（ 读写内存、读写磁盘、读写网卡）是限制计算机性能的最大瓶颈，")]),a._v(" "),n("li",[a._v("异步I/O")])])])])]),a._v(" "),n("li",[n("p",[a._v("异步I/O进化之路")]),a._v(" "),n("ul",[n("li",[a._v("网络I/O是目前最大的I/O瓶颈，诸多异步框架都对准的是网络I/O。")]),a._v(" "),n("li",[a._v("以爬虫为例，从因特网下载十片文章\n"),n("ul",[n("li",[a._v("同步阻塞方式\n"),n("ul",[n("li",[a._v("依次下载，")]),a._v(" "),n("li",[a._v("效率低下")])])]),a._v(" "),n("li",[a._v("多进程\n"),n("ul",[n("li",[a._v("开10个进程执行")]),a._v(" "),n("li",[a._v("切换开销大，支持规模小（数十到数百）")])])]),a._v(" "),n("li",[a._v("多线程\n"),n("ul",[n("li",[a._v("线程的数据结构比进程更轻量级，同一个进程可以容纳多个线程")]),a._v(" "),n("li",[a._v("支持规模不够大（数百个到数千个）")]),a._v(" "),n("li",[a._v("主要问题： 竞态条件（无序，需要锁或者同步队列来保证下载顺序不会重复执行）")])])]),a._v(" "),n("li",[a._v("非阻塞方式\n"),n("ul",[n("li",[a._v("原始")]),a._v(" "),n("li",[a._v("改进\n"),n("ol",[n("li",[a._v("epoll（linux）：让应用程序可以通过select注册文件描述符和回调函数。当文件描述符的状态发生变化时，select 就调用事先注册的回调函数")]),a._v(" "),n("li",[a._v("向 selector 注册回调（callback）函数")]),a._v(" "),n("li",[a._v("事件循环（循环selector，获取当前正在发生的事件）\n"),n("ul",[n("li",[a._v("等待事件通知的循环")]),a._v(" "),n("li",[a._v("可以算作异步编程（并不是异步。本质上是同步I/O，需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的）")]),a._v(" "),n("li",[a._v("支持规模达到（数万到数十万个）")]),a._v(" "),n("li",[a._v("问题：\n"),n("ul",[n("li",[a._v("回调层次过多时代码可读性差")]),a._v(" "),n("li",[a._v("破坏代码结构")]),a._v(" "),n("li",[a._v("共享状态管理困难")]),a._v(" "),n("li",[a._v("错误处理困难")])])])])])])])])])])])])]),a._v(" "),n("li",[n("p",[a._v("Python对异步I/O的优化")]),a._v(" "),n("ul",[n("li",[a._v("回调之痛，以始为终\n"),n("ul",[n("li",[a._v("在事件循环+回调的基础上衍生出了基于协程的解决方案")]),a._v(" "),n("li",[a._v("代表作有 Tornado、Twisted、asyncio 等")])])])])])]),a._v(" "),n("h2",{attrs:{id:"asyncio"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#asyncio"}},[a._v("#")]),a._v(" asyncio")]),a._v(" "),n("p",[n("a",{attrs:{href:"https://www.lylinux.net/article/2019/6/9/57.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("asyncio"),n("OutboundLink")],1)]),a._v(" "),n("div",{staticClass:"language-python extra-class"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" asyncio\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" threading\n\n\n"),n("span",{pre:!0,attrs:{class:"token decorator annotation punctuation"}},[a._v("@asyncio"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("coroutine")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("def")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("hello")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("print")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v("'Hello world! (%s)'")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("%")]),a._v(" threading"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("currentThread"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("yield")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("from")]),a._v(" asyncio"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("sleep"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("print")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v("'Hello again! (%s)'")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("%")]),a._v(" threading"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("currentThread"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\nloop "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" asyncio"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("get_event_loop"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\ntasks "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("hello"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" hello"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\nloop"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("run_until_complete"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("asyncio"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("wait"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("tasks"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\nloop"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("close"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),n("p",[a._v("如果把asyncio.sleep()换成真正的IO操作，则多个coroutine就可以由一个线程并发执行。")]),a._v(" "),n("p",[n("span",{staticStyle:{"background-color":"#ffaaaa"}},[n("span",{staticStyle:{"background-color":"#ffaaaa"}},[a._v("可以用单线程+")]),n("span",{staticStyle:{"background-color":"#ffaaaa"}},[a._v("coroutine")]),n("span",{staticStyle:{"background-color":"#ffaaaa"}},[a._v("实现多用户的高并发支持。")])])]),a._v(" "),n("ul",[n("li",[a._v("async / await")]),a._v(" "),n("li",[a._v("asyncio实现了TCP、UDP、SSL等协议，aiohttp则是基于asyncio实现的HTTP框架。")])]),a._v(" "),n("h2",{attrs:{id:"asyncio中的基本概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#asyncio中的基本概念"}},[a._v("#")]),a._v(" asyncio中的基本概念")]),a._v(" "),n("p",[a._v("可以看见，使用asyncio库我们也可以在python代码中使用async和await。在asyncio中，有四个基本概念，分别是：")]),a._v(" "),n("h3",{attrs:{id:"eventloop"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#eventloop"}},[a._v("#")]),a._v(" Eventloop")]),a._v(" "),n("p",[a._v("Eventloop可以说是asyncio应用的核心，中央总控，Eventloop实例提供了注册、取消、执行任务和回调 的方法。 简单来说，就是我们可以把一些异步函数注册到这个事件循环上，事件循环回循环执行这些函数（每次只能执行一个），如果当前正在执行的函数在等待I/O返回，那么事件循环就会暂停它的执行去执行其他函数。当某个函数完成I/O后会恢复，等到下次循环到它的时候就会继续执行。")]),a._v(" "),n("h3",{attrs:{id:"coroutine"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#coroutine"}},[a._v("#")]),a._v(" Coroutine")]),a._v(" "),n("p",[a._v("协程本质就是一个函数，")]),a._v(" "),n("h3",{attrs:{id:"future"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#future"}},[a._v("#")]),a._v(" Future")]),a._v(" "),n("p",[a._v("Future是表示一个“未来”对象，类似于javascript中的promise，当异步操作结束后会把最终结果设置到这个Future对象上，Future是对协程的封装。")]),a._v(" "),n("h3",{attrs:{id:"task"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#task"}},[a._v("#")]),a._v(" Task")]),a._v(" "),n("p",[a._v("Eventloop除了支持协程，还支持注册Future和Task2种类型的对象，而Future是协程的封装，Future对象提供了很多任务方法（如完成后的回调，取消，设置任务结果等等），但是一般情况下开发者不需要操作Future这种底层对象，而是直接用Future的子类Task协同的调度协程来实现并发。那么什么是Task呢？下面介绍下：")]),a._v(" "),n("p",[a._v("一个与Future类似的对象，可运行__Python__协程。非线程安全。Tas对象被用来在事件循环中运行协程。如果一个协程在等待一个Future对象，Task对象会挂起该协程的执行并等待该Future对象完成。当该Future对象完成被打包的协程将恢复执行。 事件循环使用协程调度； 一个事件循环每次运行一个Task对象。而一个Task对象等待一个Future对象完成时，该事件循环会运行其他Task、回调或执行IO操作。")]),a._v(" "),n("h2",{attrs:{id:"asyncio中一些常见用法的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#asyncio中一些常见用法的区别"}},[a._v("#")]),a._v(" asyncio中一些常见用法的区别")]),a._v(" "),n("h3",{attrs:{id:"asyncio-gather和asyncio-wait"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#asyncio-gather和asyncio-wait"}},[a._v("#")]),a._v(" Asyncio.gather和asyncio.wait")]),a._v(" "),n("ol",[n("li",[a._v("wait执行顺序是随机的，gather执行顺序是有序的")]),a._v(" "),n("li",[a._v("gather和wait都能添加一组future，但gather更支持任务分组，而wait支持更低级别的精细操作\n"),n("ol",[n("li",[a._v("wait持接受一个参数return_when，")]),a._v(" "),n("li",[a._v("在默认情况下，asyncio.wait会等待全部任务完成(return_when='ALL_COMPLETED')，")]),a._v(" "),n("li",[a._v("它还支持FIRST_COMPLETED（第一个协程完成就返回）和FIRST_EXCEPTION（出现第一个异常就返回）")])])])]),a._v(" "),n("h3",{attrs:{id:"asyncio-create-task和loop-create-task以及asyncio-ensure-future"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#asyncio-create-task和loop-create-task以及asyncio-ensure-future"}},[a._v("#")]),a._v(" asyncio.create_task和loop.create_task以及asyncio.ensure_future")]),a._v(" "),n("p",[a._v("这三种方法都可以创建Task, 从Python3.7开始可以统一的使用更高阶的asyncio.create_task.\n其实asyncio.create_task就是用的loop.create_task. \nloop.create_task接受的参数需要是一个协程，\n但是asyncio.ensure_future除了接受协程，还可以是Future对象或者awaitable对象：")]),a._v(" "),n("ol",[n("li",[a._v("如果参数是协程，其底层使用loop.create_task，返回Task对象")]),a._v(" "),n("li",[a._v("如果是Future对象会直接返回")]),a._v(" "),n("li",[a._v("如果是一个awaitable对象，会await这个对象的__await__方法，再执行一次ensure_future，最后返回Task或者Future。")])]),a._v(" "),n("p",[a._v("所以ensure_future方法主要就是确保这是一个Future对象，一般情况下直接用asyncio.create_task就可以了。")]),a._v(" "),n("h3",{attrs:{id:"注册回调和执行同步代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#注册回调和执行同步代码"}},[a._v("#")]),a._v(" 注册回调和执行同步代码")]),a._v(" "),n("p",[a._v("可以使用add_done_callback来添加成功回调：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("def callback(future):\n\n    print(f'Result: {future.result()}')\n\ndef callback2(future, n):\n\n    print(f'Result: {future.result()}, N: {n}')\n\nasync def funa():\n\n    await asyncio.sleep(1)\n\n    return \"funa\"\n\nasync def main():\n\n    task = asyncio.create_task(funa())\n\n    task.add_done_callback(callback)\n\n    await task\n\n    #这样可以为callback传递参数\n\n    task = asyncio.create_task(funa())\n\n    task.add_done_callback(functools.partial(callback2, n=1))\n\n    await task\n\nif __name__ == '__main__':\n\n    asyncio.run(main())\n")])])]),n("h4",{attrs:{id:"执行同步代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#执行同步代码"}},[a._v("#")]),a._v(" 执行同步代码")]),a._v(" "),n("p",[a._v("如果有同步逻辑，想要用asyncio来实现并发，那么需要怎么做呢？下面看看：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("def a1():\n\n    time.sleep(1)\n\n    return \"A\"\n\nasync def b1():\n\n    await asyncio.sleep(1)\n\n    return \"B\"\n\nasync def main():\n\n    loop = asyncio.get_running_loop()\n\n    await asyncio.gather(loop.run_in_executor(None, a1), b1())\n\nif __name__ == '__main__':\n\n    start = time.perf_counter()\n\n    asyncio.run(main())\n\n    print(f'main method Cost: {time.perf_counter() - start}')\n")])])]),n("blockquote",[n("p",[a._v("输出： main method Cost: 1.0050589740000002")])]),a._v(" "),n("p",[a._v("可以使用run_into_executor来将同步函数逻辑转化成一个协程，第一个参数是要传递concurrent.futures.Executor实例的，传递None会选择默认的executor。")])])}),[],!1,null,null,null);t.default=e.exports}}]);