(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{432:function(l,a,v){"use strict";v.r(a);var _=v(44),t=Object(_.a)({},(function(){var l=this,a=l.$createElement,v=l._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[v("h1",{attrs:{id:"_31-c10k问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_31-c10k问题"}},[l._v("#")]),l._v(" 31-C10K问题")]),l._v(" "),v("ul",[v("li",[v("p",[l._v(".这个概念最早由 Dan Kegel 提出，简单来说就是：单机1万个并发连接（FTP服务）问题，也就是说如何突破单机性能极限，更优化的处理高并发问题，")])]),l._v(" "),v("li",[v("p",[l._v("本质：")]),l._v(" "),v("ul",[v("li",[l._v("本质上是操作系统的问题。对于Web1.0/2.0时代的操作系统而言， 传统的同步阻塞I/O模型都是一样的，并发10K和100的区别关键在于CPU。")]),l._v(" "),v("li",[l._v("创建的进程线程多了，数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞）， 进程/线程上下文切换消耗大， 导致操作系统崩溃，这就是C10K问题的本质！")]),l._v(" "),v("li",[l._v("关键就是尽可能减少这些CPU等核心计算资源消耗")])])]),l._v(" "),v("li",[v("p",[l._v("解决思路：")]),l._v(" "),v("ul",[v("li",[l._v("每个进程/线程处理一个连接\n"),v("ul",[v("li",[l._v("资源占用过多，可扩展行差")])])]),l._v(" "),v("li",[l._v("每个进程/线程同时处理多个连接（IO多路复用）\n"),v("ul",[v("li",[l._v("解决方案：\n"),v("ul",[v("li",[l._v("select，poll，epoll（Linux独有），ICOP（Windows），libevent（跨平台）\n"),v("ul",[v("li",[l._v("epoll技术的编程模型就是异步非阻塞回调，也可以叫做Reactor，事件驱动，事件轮循（EventLoop）")]),l._v(" "),v("li",[l._v("其实epoll 已经可以较好的处理 C10K 问题，但是如果要进一步的扩展，例如支持 10M 规模的并发连接，原有的技术就无能为力了")])])]),l._v(" "),v("li",[v("span",{staticStyle:{"background-color":"#ffaaaa"}},[l._v("协程（")]),l._v(" "),v("ul",[v("li",[v("span",{staticStyle:{"background-color":"#ffaaaa"}},[l._v("本质是异步非阻塞技术")])]),l._v(" "),v("li",[v("span",{staticStyle:{"background-color":"#ffaaaa"}},[l._v("类似于同步阻塞，只不过同步阻塞是操作系统进行调度，而协程是自己内部进行调度")])]),l._v(" "),v("li",[l._v("协程的优点是它比系统线程开销小，缺点是如果其中一个协程中有密集计算，其他的协程就不运行了。操作系统进程的缺点是开销大，优点是无论代码怎么写，所有进程都可以并发运行。\n"),v("ul",[v("li",[l._v("实际上同步阻塞程序的性能并不差，它的效率很高，不会浪费资源。当进程发生阻塞后，操作系统会将它挂起，不会分配CPU。直到数据到达才会分配CPU。多进程只是开多了之后副作用太大，因为进程多了互相切换有开销。所以如果一个服务器程序只有1000左右的并发连接，同步阻塞模式是最好的。")])])])])])])])])])])]),l._v(" "),v("li",[v("h2",{attrs:{id:"异步回调和协程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异步回调和协程"}},[l._v("#")]),l._v(" 异步回调和协程")]),l._v(" "),v("ul",[v("li",[l._v("协程虽然是用户态调度，实际上还是需要调度的，既然调度就会存在上下文切换。所以协程虽然比操作系统进程性能要好，但总还是有额外消耗的。而异步回调是没有切换开销的，它等同于顺序执行代码。所以异步回调程序的性能是要优于协程模型的。")])])]),l._v(" "),v("li",[v("p",[l._v("C10k")]),l._v(" "),v("ul",[v("li",[l._v("当同时连接数在10K左右时，传统模型就不再适用。实际上在效率测试报告的线程切换开销一节可以看到，超过1K后性能就差的一塌糊涂了。")]),l._v(" "),v("li",[l._v("进程模型\n"),v("ul",[v("li",[l._v("在C10K的时候，启动和关闭这么多进程是不可接受的开销。事实上单纯的进程fork模型在C1K时就应当抛弃了。")])])]),l._v(" "),v("li",[l._v("线程模型\n"),v("ul",[v("li",[l._v("从任何测试都可以表明，线程模式比进程模式更耐久一些，性能更好。但是在面对C10K还是力不从心的。问题是，线程模式的问题出在哪里呢？")])])]),l._v(" "),v("li",[v("span",{staticStyle:{"background-color":"#ffaaaa"}},[l._v("协程模型")]),l._v(" "),v("ul",[v("li",[v("span",{staticStyle:{"background-color":"#ffaaaa"}},[l._v("比系统开销更小，可以很轻易的处理高并发访问")])]),l._v(" "),v("li",[v("span",{staticStyle:{"background-color":"#ffaaaa"}},[l._v("gevent，自动切换上下文")])])])]),l._v(" "),v("li",[l._v("回调模型（CPS模型）\n"),v("ul",[v("li",[l._v("在IO调用的时候，同时传入一个函数，作为返回函数。当IO结束时，调用传入的函数来处理下面的流程。")]),l._v(" "),v("li",[l._v("CPS模型：把一切操作都当作了IO，无论干什么，结果要通过回调函数来返回")])])]),l._v(" "),v("li",[l._v("状态机模型\n"),v("ul",[v("li",[l._v("本质是每次重入（基本已经不用）")])])])])])])])}),[],!1,null,null,null);a.default=t.exports}}]);