(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{434:function(t,s,a){"use strict";a.r(s);var r=a(44),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_42-elasticsearch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_42-elasticsearch"}},[t._v("#")]),t._v(" 42-Elasticsearch")]),t._v(" "),a("p",[t._v("问题")]),t._v(" "),a("ol",[a("li",[t._v("说一说ES\n"),a("ol",[a("li",[t._v("一个兼有")]),t._v(" "),a("li",[t._v("是 面向文档型数据库")]),t._v(" "),a("li",[t._v("采用倒排索引，")]),t._v(" "),a("li",[a("strong",[t._v("如果需要中分分支需要安装插件，")])])])]),t._v(" "),a("li",[t._v("ES搜索引擎 如何根据文档中的type进行：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("2.2 查询某个index下所有的type: \n$ curl localhost:9200/films/_search \n\n2.3 查询某个index 下， 某个 type下所有的记录： \n$ curl localhost:9200/films/md/_search?pretty=true \n\n")])])]),a("ul",[a("li",[t._v("ES实现\n"),a("ol",[a("li",[t._v("Elasticsearch 不支持对中文进行分词建立索引（倒排索引："),a("strong",[t._v("也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射")]),t._v("），需要配合扩展\n"),a("ul",[a("li",[t._v("./bin/elasticsearch-plugin install"),a("a",{attrs:{href:"https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.3.0/elasticsearch-analysis-ik-6.3.0.zip",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.3.0/elasticsearch-analysis-ik-6.3.0.zip"),a("OutboundLink")],1)])])]),t._v(" "),a("li",[t._v("修改配置文件")]),t._v(" "),a("li",[t._v("使用haystack 对接Elasticsearch\n"),a("ol",[a("li",[t._v("Haystack为Django提供了模块化的搜索。它的特点是统一的，熟悉的API，可以让你在不修改代码的情况下使用不同的搜索后端（比如 Solr, Elasticsearch, Whoosh, Xapian 等等）")]),t._v(" "),a("li",[t._v("pip install elasticsearch==2.4.1\npip install drf-haystackdrf-haystack是为了在REST framework中使用haystack而进行的封装（如果在Django中使用haystack，则安装django-haystack即可）")]),t._v(" "),a("li",[t._v("注册应用")]),t._v(" "),a("li",[t._v("在配置文件中配置haystack使用的搜索引擎后端\n"),a("ul",[a("li",[t._v("HAYSTACK_SIGNAL_PROCESSOR ='haystack.signals.RealtimeSignalProcessor'\n"),a("h1",{attrs:{id:"当添加、修改、删除数据时-自动生成索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#当添加、修改、删除数据时-自动生成索引"}},[t._v("#")]),t._v(" 当添加、修改、删除数据时，自动生成索引")])])])]),t._v(" "),a("li",[t._v("创建索引类\n"),a("ul",[a("li",[t._v("指明让搜索引擎对哪些字段建立索引")]),t._v(" "),a("li",[t._v("text = indexes.CharField(document=True, use_template=True)\n"),a("ul",[a("li",[t._v("document=True，表名该字段是主要进行关键字查询的字段")]),t._v(" "),a("li",[t._v("use_template=True 表示后续通过模板来指明 索引值具体由哪些模型类字段组成")])])])])]),t._v(" "),a("li",[t._v("创建text字段使用的模板文件")]),t._v(" "),a("li",[t._v("手动生成初始索引\n"),a("ul",[a("li",[t._v("python manage.py rebuild_index")])])]),t._v(" "),a("li",[t._v("创建序列化器")]),t._v(" "),a("li",[t._v("创建视图")]),t._v(" "),a("li",[t._v("定义路由")])])])])])]),t._v(" "),a("p",[t._v("开源的 "),a("a",{attrs:{href:"https://blog.csdn.net/cnweike/article/details/33736429",target:"_blank",rel:"noopener noreferrer"}},[t._v("Elasticsearch"),a("OutboundLink")],1),t._v(" 是目前全文搜索引擎的首选")]),t._v(" "),a("p",[t._v("它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它")]),t._v(" "),a("p",[t._v("Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。"),a("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("Elasticsearch 是用Java实现的。")]),t._v(" "),a("p",[t._v("elasticsearch 是一个兼有搜索引擎和NoSQL数据库功能的开源系统，基于Java/Lucene构建，可以用于全文搜索，结构化搜索以及近实时分析。可以说Lucene是当今最先进，最高效的全功能开源搜索引擎框架。 说明： Lucene：只是一个框架，要充分利用它的功能，需要使用JAVA，并且在程序中集成Lucene，学习成本高，Lucene确实非常复杂。 Elasticsearch 是 面向文档型数据库，这意味着它存储的是整个对象或者 文档，它不但会存储它们，还会为他们建立索引，这样你就可以搜索他们了。 在通过搜索引擎搜索时，搜索引擎将关键字在索引数据中进行快速对比查找，进而找到数据的真实存储位置")]),t._v(" "),a("h3",{attrs:{id:"elasticsearch的index"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#elasticsearch的index"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Elasticsearch的index")])]),t._v(" "),a("p",[t._v("Elasticsearch的索引(index)是用于组织数据的逻辑命名空间（如数据库）。Elasticsearch的索引有一个或多个分片(shard)（默认为5）。分片是实际存储数据的Lucene索引，它本身就是一个搜索引擎。每个分片可以有零个或多个副本(replicas)（默认为1）。Elasticsearch索引还具有“类型”（如数据库中的表），允许您在索引中对数据进行逻辑分区。Elasticsearch索引中给定“类型”中的所有文档(documents)具有相同的属性（如表的模式）。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdn.net/20170814225416168?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemdfaG92ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:""}})]),t._v(" "),a("p",[t._v("图a显示了一个由三个主分片组成的Elasticsearch集群，每个主分片分别有一个副本。所有这些分片一起形成一个Elasticsearch索引，每个分片是Lucene索引本身。")]),t._v(" "),a("p",[t._v("图b演示了Elasticsearch索引，分片，Lucene索引和文档(document)之间的逻辑关系。")]),t._v(" "),a("h4",{attrs:{id:"类比关系数据库术语"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类比关系数据库术语"}},[t._v("#")]),t._v(" "),a("strong",[t._v("类比关系数据库术语")])]),t._v(" "),a("p",[t._v("Elasticsearch Index ~ Database")]),t._v(" "),a("p",[t._v("Types ~ Tables")]),t._v(" "),a("p",[t._v("Mapping ~ Schema")]),t._v(" "),a("p",[a("strong",[t._v("关系数据库 ⇒ 数据库 ⇒ 表 ⇒ 行 ⇒ 列(Columns)")])]),t._v(" "),a("p",[a("strong",[t._v("Elasticsearch ⇒ 索引 ⇒ 类型 ⇒ 文档 ⇒ 字段(Fields)")])]),t._v(" "),a("p",[t._v("schema  MySQL的文档中指出，在物理上，模式与数据库是同义的，所以，模式和数据库是一回事")]),t._v(" "),a("h3",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"目录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[t._v("#")]),t._v(" "),a("strong",[t._v("目录：")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("应用场景")])]),t._v(" "),a("li",[a("strong",[t._v("solr VS ES")])]),t._v(" "),a("li",[a("strong",[t._v("核心概念")])]),t._v(" "),a("li",[a("strong",[t._v("ES模块结构")])]),t._v(" "),a("li",[a("strong",[t._v("分片示例")])])]),t._v(" "),a("p",[a("strong",[t._v("应用场景")])]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[a("strong",[t._v("站内搜索：")])]),t._v(" "),a("li",[a("strong",[t._v("NoSQL json文档数据库：")])]),t._v(" "),a("li",[a("strong",[t._v("监控：")])]),t._v(" "),a("li",[a("strong",[t._v("国外：Wikipedia使用 ES 提供全文搜索并高亮关键字、StackOverflow结合全文搜索与地理位置查询、")])]),t._v(" "),a("li",[a("strong",[t._v("国内：")])]),t._v(" "),a("li",[a("strong",[t._v("使用比较广泛的平台ELK(ElasticSearch, Logstash, "),a("strong",[t._v("Kibana")])]),t._v(")****")])]),t._v(" "),a("p",[a("strong",[t._v("solr VS ES")])]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Solr是Apache Lucene项目的开源企业搜索平台。其主要功能包括全文检索、命中标示、分面搜索、动态聚类、数据库集成，以及富文本（如Word、PDF）的处理。")])]),t._v(" "),a("li",[a("strong",[t._v("Solr是高度可扩展的，并提供了分布式搜索和索引复制。Solr是最流行的企业级搜索引擎，Solr4 还增加了NoSQL支持。")])]),t._v(" "),a("li",[a("strong",[t._v("Solr是用Java编写、运行在Servlet容器（如 Apache Tomcat 或Jetty）的一个独立的全文搜索服务器。 Solr采用了 Lucene Java 搜索库为核心的全文索引和搜索，并具有类似REST的HTTP/XML和JSON的API。")])]),t._v(" "),a("li",[a("strong",[t._v("Solr强大的外部配置功能使得无需进行Java编码，便可对 其进行调整以适应多种类型的应用程序。Solr有一个插件架构，以支持更多的高级定制")])]),t._v(" "),a("li",[a("strong",[t._v("Elasticsearch 与 Solr 的比较总结")])])]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("二者安装都很简单")])]),t._v(" "),a("li",[a("strong",[t._v("Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能")])]),t._v(" "),a("li",[a("strong",[t._v("Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式")])]),t._v(" "),a("li",[a("strong",[t._v("Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供")])]),t._v(" "),a("li",[a("strong",[t._v("Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch")])]),t._v(" "),a("li",[a("strong",[t._v("Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用")])])]),t._v(" "),a("p",[a("strong",[t._v("核心概念")])]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[a("strong",[t._v("集群（Cluster):")])])]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("集群内节点协同工作，共享数据，并共同分担工作负荷。")])]),t._v(" "),a("li",[a("strong",[t._v("由于节点是从属集群的，集群会自我重组来")])]),t._v(" "),a("li",[a("strong",[t._v("cluster Name是很重要的，因为每个节点只能是群集的一部分，当该节点被设置为相同的名称时，就会")])]),t._v(" "),a("li",[a("strong",[t._v("集群中通过选举产生")])]),t._v(" "),a("li",[a("strong",[t._v("作为用户，我们可以访问包括 master 节点在内的集群中的任一节点。每个节点都知道各个文档的位置，并能够将我们的请求直接转发到拥有我们想要的数据的节点。无论我们访问的是哪个节点，它都会控制从拥有数据的节点收集响应的过程，并返回给客户端最终的结果。这一切都是由 Elasticsearch 透明管理的")])])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("节点(node):")])]),t._v(" "),a("li",[a("strong",[t._v("索引（Index)：")])]),t._v(" "),a("li",[a("strong",[t._v("文档类型（Type）：")])]),t._v(" "),a("li",[a("strong",[t._v("关系数据库 ⇒ 数据库 ⇒ 表 ⇒ 行 ⇒ 列(Columns)")]),t._v(" "),a("strong",[t._v("Elasticsearch ⇒ 索引 ⇒ 类型 ⇒ 文档 ⇒ 字段(Fields)")]),t._v(" "),a("strong",[t._v("文档（Document) ：")])]),t._v(" "),a("li",[a("strong",[t._v("模拟示意图如：")])]),t._v(" "),a("li",[a("img",{attrs:{src:"https://images2015.cnblogs.com/blog/1004194/201611/1004194-20161124180138409-1933404824.png",alt:""}})]),t._v(" "),a("li",[a("strong",[t._v("Mapping：")])]),t._v(" "),a("li",[a("strong",[t._v("分片(shard) ：")])])]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("分片是一个独立的Lucene实例，并且它自身也是一个完整的搜索引擎。")])]),t._v(" "),a("li",[a("strong",[t._v("文档存储并且被索引在分片中，但是我们的程序并不会直接与它们通信。取而代之，它们直接与索引进行通信的")])]),t._v(" "),a("li",[a("strong",[t._v("把")])]),t._v(" "),a("li",[a("strong",[t._v("分片分为 主分片(primary shard) 以及 从分片(replica shard) 两种。在你的索引中，每一个文档都属于一个主分片")])]),t._v(" "),a("li",[a("strong",[t._v("从")])]),t._v(" "),a("li",[a("strong",[t._v("索引中的")])]),t._v(" "),a("li",[a("strong",[t._v("一个索引默认设置了5个主分片，每个主分片有一个从分片对应")])])]),t._v(" "),a("p",[a("strong",[t._v("ES模块结构")])]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[a("strong",[t._v("模块结构图如下")])]),t._v(" "),a("li",[a("img",{attrs:{src:"https://images2015.cnblogs.com/blog/1004194/201611/1004194-20161124185700128-46209682.png",alt:""}})]),t._v(" "),a("li",[a("strong",[t._v("Gateway:")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("对于分布式集群来说，当一个或多个节点down掉了，能够保证我们的数据不能丢，最通用的解放方案就是对失败节点的数据进行复制，通过控制复制的份数可以保证集群有很高的可用性，复制这个方案的精髓主要是保证操作的时候没有单点，对一个节点的操作会同步到其他的复制节点上去。")])]),t._v(" "),a("li",[a("strong",[t._v("$ curl -XPUT")]),a("a",{attrs:{href:"http://localhost:9200/twitter/",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://localhost:9200/twitter/"),a("OutboundLink")],1),a("strong",[t._v("-d****'")]),t._v(" "),a("strong",[t._v("index :")]),t._v("\n**number_of_shards 😗*"),a("strong",[t._v("3")]),t._v("\n**number_of_replicas 😗*"),a("strong",[t._v("2")]),t._v(" "),a("strong",[t._v("ES一个")])]),t._v(" "),a("li",[a("strong",[t._v("每个操作会自动路由主碎片所在的节点，在上面执行操作，并且同步到其他复制节点，通过使用“non blocking IO”模式所有复制的操作都是并行执行的，也就是说如果你的")])]),t._v(" "),a("li",[a("strong",[t._v("第一次启动的时候，它会去持久化设备读取集群的状态信息（创建的索引，配置等）然后执行应用它们（创建索引，创建mapping映射等），每一次shard节点第一次实例化加入复制组，它都会从长持久化存储里面恢复它的状态信息")])])])]),t._v(" "),a("li",[a("strong",[t._v("Lucence Directory:�")]),t._v("�\n"),a("ol",[a("li",[a("strong",[t._v("它是Lucene存储的一个抽象，由此派生了两个类：")])]),t._v(" "),a("li",[a("img",{attrs:{src:"https://images2015.cnblogs.com/blog/1004194/201611/1004194-20161125104550456-1075794774.png",alt:""}})]),t._v(" "),a("li",[a("strong",[t._v("一个Directory对象是一份文件的清单。文件可能只在被创建的时候写一次。一旦文件被创建，它将只被读取或者删除。在读取的时候进行写入操作是允许的")])])])]),t._v(" "),a("li",[a("strong",[t._v("Discovery")])])]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("节点启动后")])]),t._v(" "),a("li",[a("strong",[t._v("Ping的response会包含该节点的基本信息以及该节点认为的master节点")])]),t._v(" "),a("li",[a("strong",[t._v("选举开始，先从各节点认为的master中选，规则很简单，按照id的字典序排序，取第一个")])]),t._v(" "),a("li",[a("strong",[t._v("如果各节点都没有认为的master，则从所有节点中选择，规则同上。这里有个限制条件就是")])]),t._v(" "),a("li",[a("strong",[t._v("最后选举结果是肯定能选举出一个master，如果只有一个local节点那就选出的是自己")])]),t._v(" "),a("li",[a("strong",[t._v("如果当前节点是master，则开始等待节点数达到 minimum_master_nodes，然后提供服务, 如果当前节点不是master，则尝试加入master.")])]),t._v(" "),a("li",[a("strong",[t._v("ES支持任意数目的集群（1-N）,所以不能像 Zookeeper/Etcd 那样限制节点必须是奇数，也就无法用投票的机制来选主，而是通过一个规则，只要所有的节点都遵循同样的规则，得到的信息都是对等的，选出来的主节点肯定是一致的. 但分布式系统的问题就出在")])])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("memcached")])])]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("通过memecached协议来访问ES的接口,支持二进制和文本两种协议.通过一个名为transport-memcached插件提供")])]),t._v(" "),a("li",[a("strong",[t._v("Memcached命令会被映射到REST接口，并且会被同样的REST层处理，memcached命令列表包括：get/set/delete/quit")])])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("River :")])])]),t._v(" "),a("p",[a("strong",[t._v("分片示例")])]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[a("strong",[t._v("启用一个既没有数据，也没有索引的单一节点, 如下图")])]),t._v(" "),a("li",[a("img",{attrs:{src:"https://images2015.cnblogs.com/blog/1004194/201611/1004194-20161125113639190-848778968.png",alt:""}})]),t._v(" "),a("li",[t._v("**PUT /"),a("strong",[a("strong",[t._v("blogs")]),t._v(" "),a("strong",[t._v("{")]),t._v(" "),a("strong",[t._v('"'),a("strong",[a("strong",[t._v("settings")])]),t._v('"')]),t._v("**: {")]),t._v(" "),a("strong",[t._v('"'),a("strong",[a("strong",[t._v("number_of_shards")])]),t._v('"'),a("strong",[a("strong",[t._v(": 3")])]),t._v(",")]),t._v(" "),a("strong",[t._v('"'),a("strong",[a("strong",[t._v("number_of_replicas")])]),t._v('"****: 1')]),t._v(" "),a("strong",[t._v("}")]),t._v(" "),a("strong",[t._v("}")]),t._v(" "),a("strong",[t._v("在空的单节点集群中上创建一个叫做 blogs 的索引，设置3个主分片和一组从分片（每个主分片有一个从分片对应），代码如下：")])]),t._v(" "),a("li",[t._v("** 集群示例图如下： （**")]),t._v(" "),a("li",[a("img",{attrs:{src:"https://images2015.cnblogs.com/blog/1004194/201611/1004194-20161125113848987-1256292980.png",alt:""}})]),t._v(" "),a("li",[a("strong",[t._v("主分片(primary shards) 启动并且运行了，这时集群已经可以成功的处理任意请求，但是 从分片(replica shards) 没有完全被激活。事实上，当前这三个从分片都处于 unassigned（未分配）的状态，它们还未被分配到节点上。在同一个节点上保存相同的数据副本是没有必要的，如果这个节点故障了，就等同于所有的数据副本也丢失了")])]),t._v(" "),a("li",[a("strong",[t._v("启动第二个节点，配置第二个节点与第一个节点的 cluster.name 相同（./config/elasticsearch.yml文件中的配置），它就能自动发现并加入到第一个节点的集群中,如下图：")])]),t._v(" "),a("li",[a("img",{attrs:{src:"https://images2015.cnblogs.com/blog/1004194/201611/1004194-20161125114323550-385234299.png",alt:""}})]),t._v(" "),a("li",[a("strong",[t._v("cluster-health 的状态为 green，这意味着所有的6个分片（三个主分片和三个从分片）都已激活，文档在主节点和从节点上都能被检索")])]),t._v(" "),a("li",[a("strong",[t._v("随着应用需求的增长，启动第三个节点进行横向扩展，集群内会自动重组，如图")])]),t._v(" "),a("li",[a("img",{attrs:{src:"https://images2015.cnblogs.com/blog/1004194/201611/1004194-20161125114656253-121641653.png",alt:""}})]),t._v(" "),a("li",[a("strong",[t._v("在 Node 1 和 Node 2 中分别会有一个分片被移动到 Node 3 上，这样一来，每个节点上就都只有两个分片了。这意味着每个节点的硬件资源（CPU、RAM、I/O）被更少的分片共享，所以每个分片就会有更好的性能表现")])]),t._v(" "),a("li",[a("strong",[t._v("一共有6个分片（3个主分片和3个从分片），因此最多可以扩展到6个节点，每个节点上有一个分片，这样每个分片都可以使用到所在节点100%的资源了")])]),t._v(" "),a("li",[a("strong",[t._v("主分片的数量在索引创建的时候就已经指定了，实际上，这个数字定义了能存储到索引中的数据最大量（具体的数量取决于你的数据，硬件的使用情况）。例如，读请求——搜索或者文档恢复就可以由主分片或者从分片来执行，所以当你拥有更多份数据的时候，你就拥有了更大的吞吐量")])]),t._v(" "),a("li",[a("strong",[t._v("PUT /blogs/****_settings")]),t._v(" "),a("strong",[t._v("{")]),t._v(" "),a("strong",[t._v('"'),a("strong",[a("strong",[t._v("number_of_replicas")])]),t._v('"****: 2')]),t._v(" "),a("strong",[t._v("}")]),t._v(" "),a("strong",[t._v("从分片的数量可以在运行的集群中动态的调整，这样我们就可以根据实际需求扩展或者缩小规模。接下来，我们来增加一下从分片组的数量：")])]),t._v(" "),a("li",[t._v("** 现在 blogs 的索引总共有9个分片：3个主分片和6个从分片， 又会变成一个节点一个分片的状态了,最终得到了三倍搜索性能的三节点集群**")]),t._v(" "),a("li",[a("img",{attrs:{src:"https://images2015.cnblogs.com/blog/1004194/201611/1004194-20161125115353034-132051281.png",alt:""}})]),t._v(" "),a("li",[a("strong",[t._v("说明：仅仅是在同样数量的节点上增加从分片的数量是根本不能提高性能的，因为每个分片都有访问系统资源的权限。你需要升级硬件配置以提高吞吐量。")])]),t._v(" "),a("li",[a("strong",[t._v("尝试一下,把第一个节点杀掉，我们的集群就会如下图所示：")])]),t._v(" "),a("li",[a("img",{attrs:{src:"https://images2015.cnblogs.com/blog/1004194/201611/1004194-20161125115935112-1907307214.png",alt:""}})]),t._v(" "),a("li",[a("strong",[t._v("被杀掉的节点是主节点，主分片 1 和 2 在我们杀掉 Node 1 后就丢失了，我们的索引在丢失主节点的时候是不能正常工作的。如果我们在这个时候检查集群健康状态，将会显示 red：存在不可用的主节点")])]),t._v(" "),a("li",[a("strong",[t._v("而为了集群的正常工作必须需要一个主节点，所以首先进行的进程就是从各节点中选择了一个新的主节点：Node 2")])]),t._v(" "),a("li",[a("strong",[t._v("新的主节点所完成的第一件事情就是将这些在 Node 2 和 Node 3 上的从分片提升为主分片，然后集群的健康状态就变回至 yellow。这个提升的进程是瞬间完成了，就好像按了一下开关")])]),t._v(" "),a("li",[a("strong",[t._v("如果再次杀掉 Node 2 的时候，我们的程序依旧可以在没有丢失任何数据的情况下运行，因为 Node 3 中依旧拥有每个分片的备份")])]),t._v(" "),a("li",[a("strong",[t._v("如果我们重启 Node 1，集群就能够重新分配丢失的从分片，这样结果就会与三节点两从集群一致。如果 Node 1 依旧还有旧节点的内容，系统会尝试重新利用他们，并只会复制在故障期间的变更数据")])])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#-2"}},[t._v("#")])]),t._v(" "),a("h3",{attrs:{id:"-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#-3"}},[t._v("#")])]),t._v(" "),a("h3",{attrs:{id:"-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#-4"}},[t._v("#")])]),t._v(" "),a("h3",{attrs:{id:"-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#-5"}},[t._v("#")])]),t._v(" "),a("h3",{attrs:{id:"-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#-6"}},[t._v("#")])]),t._v(" "),a("h3",{attrs:{id:"-7"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#-7"}},[t._v("#")])]),t._v(" "),a("h3",{attrs:{id:"-8"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#-8"}},[t._v("#")])]),t._v(" "),a("h3",{attrs:{id:"-9"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#-9"}},[t._v("#")])]),t._v(" "),a("h3",{attrs:{id:"elasticsearch集群的节点类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#elasticsearch集群的节点类型"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Elasticsearch集群的节点类型")])]),t._v(" "),a("p",[t._v("Elasticsearch的一个实例是一个节点，一组节点形成一个集群。Elasticsearch集群中的节点可以通过三种不同的方式进行配置：")]),t._v(" "),a("h4",{attrs:{id:"master节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#master节点"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Master节点")])]),t._v(" "),a("p",[t._v("Master节点控制Elasticsearch集群，并负责在集群范围内创建/删除索引，跟踪哪些节点是集群的一部分，并将分片分配给这些节点。主节点一次处理一个集群状态，并将状态广播到所有其他节点，这些节点需要响应并确认主节点的信息。")]),t._v(" "),a("p",[t._v("在elasticsearch.yml中，将nodes.master属性设置为true（默认），可以将节点配置为有资格成为主节点的节点。")]),t._v(" "),a("p",[t._v("对于大型生产集群，建议用一个专用主节点来控制集群，并且不服务任何用户请求。")]),t._v(" "),a("h4",{attrs:{id:"data节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data节点"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Data节点")])]),t._v(" "),a("p",[t._v("数据节点用来保存数据和倒排索引。默认情况下，每个节点都配置为一个data节点，并且在elasticsearch.yml中将属性node.data设置为true。如果您想要一个专用的master节点，那么将node.data属性更改为false。")]),t._v(" "),a("h4",{attrs:{id:"client节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#client节点"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Client节点")])]),t._v(" "),a("p",[t._v("如果将node.master和node.data设置为false，则将节点配置为客户端节点，并充当负载平衡器，将传入的请求路由到集群中的不同节点。")]),t._v(" "),a("p",[t._v("若你连接的是作为客户端的节点，该节点称为协调节点(coordinating node)。协调节点将客户机请求路由到集群中对应分片所在的节点。对于读取请求，协调节点每次选择不同的分片来提供请求以平衡负载。")]),t._v(" "),a("p",[t._v("在我们开始审查发送到协调节点的CRUD请求如何通过集群传播并由引擎执行之前，让我们看看Elasticsearch如何在内部存储数据，以低延迟为全文搜索提供结果。")]),t._v(" "),a("h4",{attrs:{id:"存储模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储模型"}},[t._v("#")]),t._v(" "),a("strong",[t._v("存储模型")])]),t._v(" "),a("p",[t._v("Elasticsearch使用Apache Lucene，它是由Java编写的全文搜索库，由Doug Cutting（Apache Hadoop的创建者）内部开发，它使用称为倒排索引的数据结构，用于提供低延迟搜索结果。")]),t._v(" "),a("p",[t._v("文档（document）是Elasticsearch中的数据单位，并通过对文档中的术语进行标记来创建倒排索引，创建所有唯一术语的排序列表，并将文档列表与可以找到该词的位置相关联。")]),t._v(" "),a("p",[t._v("它非常类似于一本书背面的索引，其中包含书中的所有独特的单词和可以找到该单词的页面列表。当我们说一个文档被索引时，我们引用倒排索引。我们来看看下面两个文档的倒排索引如何看待：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdn.net/20170814225953744?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemdfaG92ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:""}})]),t._v(" "),a("p",[t._v("如果我们想要找到包含术语“insight”的文档，我们可以扫描倒排的索引（在哪里排序），找到“insight”这个词，并返回包含这个单词的文档ID，这在这种情况下将是文档1和Doc 2号文件。")]),t._v(" "),a("p",[t._v("为了提高可搜索性（例如，为小写字母和小写字提供相同的结果），首先分析文档并对其进行索引。")]),t._v(" "),a("p",[t._v("分析由两部分组成：")]),t._v(" "),a("p",[t._v("将句子标记成单词")]),t._v(" "),a("p",[t._v("将单词规范化为标准表单")]),t._v(" "),a("p",[t._v("默认情况下，Elasticsearch使用标准分析器")]),t._v(" "),a("p",[t._v("标准标记器(Standard tokenizer)，用于在单词边界上分割单词")]),t._v(" "),a("p",[t._v("小写令牌过滤器(Lowercase token filter)将单词转换为小写")]),t._v(" "),a("p",[t._v("还有许多其他分析仪可用，您可以在文档中阅读它们。")]),t._v(" "),a("p",[t._v("注意：标准分析仪也使用停止令牌过滤器，但默认情况下禁用。")]),t._v(" "),a("h2",{attrs:{id:"实现原理分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现原理分析"}},[t._v("#")]),t._v(" "),a("strong",[t._v("实现原理分析")])]),t._v(" "),a("h3",{attrs:{id:"write-写-create-创建-操作实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#write-写-create-创建-操作实现原理"}},[t._v("#")]),t._v(" "),a("strong",[t._v("write(写)/create(创建)操作实现原理")])]),t._v(" "),a("p",[t._v("当您向协调节点发送请求以索引新文档时，将执行以下操作：")]),t._v(" "),a("p",[t._v("所有在Elasticsearch集群中的节点都包含：有关哪个分片存在于哪个节点上的元数据。协调节点(coordinating node)使用文档ID（默认）将文档路由到对应的分片。Elasticsearch将文档ID以murmur3作为散列函数进行散列，并通过索引中的主分片数量进行取模运算，以确定文档应被索引到哪个分片。")]),t._v(" "),a("p",[t._v("shard = hash(document_id) % (num_of_primary_shards)")]),t._v(" "),a("p",[t._v("当节点接收到来自协调节点的请求时，请求被写入到translog（我们将在后续的post中间讲解translog），并将该文档添加到内存缓冲区。如果请求在主分片上成功，则请求将并行发送到副本分片。只有在所有主分片和副本分片上的translog被fsync’ed后，客户端才会收到该请求成功的确认。")]),t._v(" "),a("p",[t._v("内存缓冲区以固定的间隔刷新（默认为1秒），并将内容写入文件系统缓存中的新段。此分段的内容更尚未被fsync’ed(未被写入文件系统)，分段是打开的，内容可用于搜索。")]),t._v(" "),a("p",[t._v("translog被清空，并且文件系统缓存每隔30分钟进行一次fsync，或者当translog变得太大时进行一次fsync。这个过程在Elasticsearch中称为flush。在刷新过程中，内存缓冲区被清除，内容被写入新的文件分段(segment)。当文件分段被fsync’ed并刷新到磁盘，会创建一个新的提交点（其实就是会更新文件偏移量，文件系统会自动做这个操作）。旧的translog被删除，一个新的开始。")]),t._v(" "),a("p",[t._v("下图显示了写入请求和数据流程：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdn.net/20170814230326817?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemdfaG92ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"update和delete实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#update和delete实现原理"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Update和Delete实现原理")])]),t._v(" "),a("p",[t._v("删除和更新操作也是写操作。但是，Elasticsearch中的文档是不可变的(immutable)，因此不能删除或修改。那么，如何删除/更新文档呢？")]),t._v(" "),a("p",[t._v("磁盘上的每个分段(segment)都有一个.del文件与它相关联。当发送删除请求时，该文档未被真正删除，而是在.del文件中标记为已删除。此文档可能仍然能被搜索到，但会从结果中过滤掉。当分段合并时（我们将在后续的帖子中包括段合并），在.del文件中标记为已删除的文档不会被包括在新的合并段中。")]),t._v(" "),a("p",[t._v("现在，我们来看看更新是如何工作的。创建新文档时，Elasticsearch将为该文档分配一个版本号。对文档的每次更改都会产生一个新的版本号。当执行更新时，旧版本在.del文件中被标记为已删除，并且新版本在新的分段中编入索引。旧版本可能仍然与搜索查询匹配，但是从结果中将其过滤掉。")]),t._v(" "),a("p",[t._v("indexed/updated文档后，我们希望执行搜索请求。我们来看看如何在Elasticsearch中执行搜索请求。")]),t._v(" "),a("h3",{attrs:{id:"read的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#read的实现原理"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Read的实现原理")])]),t._v(" "),a("p",[t._v("读操作由两个阶段组成：")]),t._v(" "),a("p",[t._v("查询阶段（Query Phase）")]),t._v(" "),a("p",[t._v("获取阶段（Fetch Phase）")]),t._v(" "),a("h4",{attrs:{id:"查询阶段-query-phase"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查询阶段-query-phase"}},[t._v("#")]),t._v(" "),a("strong",[t._v("查询阶段(Query Phase)")])]),t._v(" "),a("p",[t._v("在此阶段，协调节点将搜索请求路由到索引(index)中的所有分片(shards)（包括：主要或副本）。分片独立执行搜索，并根据相关性分数创建一个优先级排序结果（稍后我们将介绍相关性分数）。所有分片将匹配的文档和相关分数的文档ID返回给协调节点。协调节点创建一个新的优先级队列，并对全局结果进行排序。可以有很多文档匹配结果，但默认情况下，每个分片将前10个结果发送到协调节点，协调创建优先级队列，从所有分片中分选结果并返回前10个匹配。")]),t._v(" "),a("h4",{attrs:{id:"获取阶段-fetch-phase"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#获取阶段-fetch-phase"}},[t._v("#")]),t._v(" "),a("strong",[t._v("获取阶段(Fetch Phase)")])]),t._v(" "),a("p",[t._v("在协调节点对所有结果进行排序，已生成全局排序的文档列表后，它将从所有分片请求原始文档。")]),t._v(" "),a("p",[t._v("所有的分片都会丰富文档并将其返回到协调节点。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdn.net/20170814230558199?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemdfaG92ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast",alt:""}})]),t._v(" "),a("p",[t._v("如上所述，搜索结果按相关性排序。我们来回顾一下相关性的定义。")]),t._v(" "),a("h4",{attrs:{id:"搜索相关性-search-relevance"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#搜索相关性-search-relevance"}},[t._v("#")]),t._v(" "),a("strong",[t._v("搜索相关性(Search Relevance)")])]),t._v(" "),a("p",[t._v("相关性由Elasticsearch给予搜索结果中返回的每个文档的分数确定。用于评分的默认算法为tf / idf（术语频率/逆文档频率）。该术语频率测量术语出现在文档中的次数（更高频率=更高的相关性），逆文档频率测量术语在整个索引中出现的频率占索引中文档总数的百分比（更高的频率")]),t._v(" "),a("p",[t._v("==较少的相关性）。最终得分是tf-idf分数与其他因素（如词语邻近度（短语查询）），术语相似度（用于模糊查询）等的组合。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("docker run -dti --network=host --name=elasticsearch -v\n/home/python/elasticsearch-2.4.6/config:/usr/share/elasticsearch/config delron/elasticsearch-ik:2.4.6-1.0\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);