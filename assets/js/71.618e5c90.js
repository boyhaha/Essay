(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{446:function(e,r,t){"use strict";t.r(r);var o=t(44),a=Object(o.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_40-docker"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_40-docker"}},[e._v("#")]),e._v(" 40-Docker")]),e._v(" "),t("ol",[t("li",[e._v("对docker的理解\n"),t("ol",[t("li",[e._v("一种容器，沙盒技术，可以加快服务构建流程，使其更加高效，轻量化")])])]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/Bourbon-tian/p/6867796.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("docker构建"),t("OutboundLink")],1),e._v(" "),t("ol",[t("li",[e._v("使用docker commit命令。\n"),t("ol",[t("li",[e._v("可以想象为是在往版本控制系统里提交变更。我们先创建一个容器，并在容器里做出修改，就像修改代码一样，最后再将修改提交为一个镜像")]),e._v(" "),t("li",[e._v("docker commit b437ffe4d630 test/apache2\n"),t("ol",[t("li",[e._v("指定了要提交的修改过的容器的ID（可以通过docker ps命令得到刚创建的容器ID），以及一个目标镜像仓库和镜像名，这里是test/apahce2")])])]),e._v(" "),t("li",[e._v("缺点： 不够灵活")])])]),e._v(" "),t("li",[e._v("使用docker build命令和 Dockerfile 文件\n"),t("ol",[t("li",[e._v("Dockerfile使用基本的基于DSL（")]),e._v(" "),t("li",[e._v("首先创建一个名为static_web的目录用来保存Dockerfile，这个目录就是我们的构建环境（build environment）,Docker则称此环境为上下文（context）或者构建上下文（build context）。Docker会在构建镜像时将构建上下文和该上下文中的文件和目录上传到Docker守护进程。这样Docker守护进程就能直接访问你想在镜像中存储的任何代码、文件或者其他数据。这里我们还创建了一个Dockerfile文件，我们将用它构建一个能作为Web服务器的Docker镜像。")]),e._v(" "),t("li",[e._v("Dockerfile由一系列指令和参数组成。每条指令都必须为大写字母，且后面要跟随一个参数。Dockerfile中的指令会按照顺序从上到下执行，所以应该根据需要合理安排指令的顺序。每条指令都会创建一个新的镜像层并对镜像进行提交。Docker大体上按照如下流程执行Dockerfile中的指令。\n"),t("ol",[t("li",[e._v("Docker从基础镜像运行一个容器。")]),e._v(" "),t("li",[e._v("执行第一条指令，对容器进行修改。")]),e._v(" "),t("li",[e._v("执行类似docker commit的操作，提交一个新的镜像层。")]),e._v(" "),t("li",[e._v("Docker再基于刚提交的镜像运行一个新的容器。")]),e._v(" "),t("li",[e._v("执行Dockerfile中的下一条命令，直到所有指令都执行完毕。")])])])])])])]),e._v(" "),t("li",[e._v("Docker Compose\n"),t("ol",[t("li",[e._v("用于定义和运行多容器Docker应用程序的工具\n"),t("ol",[t("li",[e._v("使用 Dockerfile 定义应用程序的环境")]),e._v(" "),t("li",[e._v("使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行")]),e._v(" "),t("li",[e._v("最后，执行 docker-compose up 命令来启动并运行整个应用程序")])])])])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# Version: 0.0.1\n  # FROM指令指定一个已经存在的镜像，后续指令都是将基于该镜像进行，这个镜像被称为基础镜像\nFROM reg.linkdoc-inc.com/dw_dp/pypy-base\nADD . /opt/dcp\nWORKDIR /opt/dcp\n\n# 告诉Docker该镜像的作者是谁，以及作者的邮箱地址\nMAINTAINER Bourbon Tian \"bourbon@1mcloud.com\"\n# RUN指令会在当前镜像中运行指定的命令\nRUN apt-get update\nRUN apt-get install -y nginx\nRUN echo 'Hi, I am in your container' > /usr/share/nginx/html/index.html\n# 告诉Docker该容器内的应用程序将会使用容器的指定端口\n  EXPOSE 80\n  CMD make server\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('# cd static_web\n#  -t选项为新镜像设置了仓库和名称。\n# docker build -t="test/static_web" .       \nSending build context to Docker daemon 2.048 kB\nSending build context to Docker daemon\n...\nSuccessfully built 94728651ce15\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('# docker run -d -p 80 --name static_web test/static_web nginx -g "daemon off;"\n-d选项，告诉Docker以分离（detached）的方式在后台运行。这种方式非常适合运行类似Nginx守护进程这样的需要长时间运行的进程\n-p/-P， 指定容器暴露的端口 ，或者添加映射\n-e, --env=[]               指定环境变量，容器中可以使用该环境变量\n-h, --hostname=""          指定容器的主机名\n -v, --volume=[]            给容器挂载存储卷，挂载到容器的某个目录\n')])])]),t("ul",[t("li",[e._v("搭建本地镜像源\n"),t("ul",[t("li",[t("h1",{attrs:{id:"docker-pull-registry"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#docker-pull-registry"}},[e._v("#")]),e._v(" docker pull registry")])]),e._v(" "),t("li",[t("h1",{attrs:{id:"docker-run-d-v-opt-registry-var-lib-registry-p-5000-5000-restart-always-name-registry-registry-latest"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#docker-run-d-v-opt-registry-var-lib-registry-p-5000-5000-restart-always-name-registry-registry-latest"}},[e._v("#")]),e._v(" docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry:latest")])]),e._v(" "),t("li",[t("h1",{attrs:{id:"使用新的registry给该镜像打上标签"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用新的registry给该镜像打上标签"}},[e._v("#")]),e._v(" 使用新的Registry给该镜像打上标签")])]),e._v(" "),t("li",[t("h1",{attrs:{id:"docker-tag-9c30616364f4-docker-example-com-5000-test-apache2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#docker-tag-9c30616364f4-docker-example-com-5000-test-apache2"}},[e._v("#")]),e._v(" docker tag 9c30616364f4 "),t("a",{attrs:{href:"http://docker.example.com:5000/test/apache2",target:"_blank",rel:"noopener noreferrer"}},[e._v("docker.example.com:5000/test/apache2"),t("OutboundLink")],1)])]),e._v(" "),t("li",[t("h1",{attrs:{id:"通过docker-push-命令将它推送到新的registry中去"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通过docker-push-命令将它推送到新的registry中去"}},[e._v("#")]),e._v(" 通过docker push 命令将它推送到新的Registry中去")])]),e._v(" "),t("li",[t("h1",{attrs:{id:"docker-push-docker-example-com-5000-test-apache2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#docker-push-docker-example-com-5000-test-apache2"}},[e._v("#")]),e._v(" docker push "),t("a",{attrs:{href:"http://docker.example.com:5000/test/apache2",target:"_blank",rel:"noopener noreferrer"}},[e._v("docker.example.com:5000/test/apache2"),t("OutboundLink")],1)])])])])]),e._v(" "),t("ol",[t("li",[e._v("docker和容器化\n"),t("ol",[t("li",[e._v("Docker是现在使用最多的容器化软件。与其它已经存在的容器化系统相比，Docker可以更加简单的创建和管理容器，并与其它开源软件集成")])])]),e._v(" "),t("li",[e._v("docker的优点\n"),t("ul",[t("li",[e._v("轻量级资源使用：容器在")]),e._v(" "),t("li",[e._v("可移植性：一个容器应用所需要的依赖都在容器中，这就让它可以在任意一台Docker主机上运行。")]),e._v(" "),t("li",[e._v("可预测性：宿主机不需要关心容器内运行的是什么，同样，容器也不需要关心是在哪个宿主机上运行。所需要的接口都是标准化的，并且交互也都是可预测的。")])])]),e._v(" "),t("li",[e._v("引擎\n"),t("ol",[t("li",[t("a",{attrs:{href:"https://www.docker.com/docker-engine",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker Engine"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://coreos.com/rkt/docs/latest/",target:"_blank",rel:"noopener noreferrer"}},[e._v("rkt"),t("OutboundLink")],1)])])]),e._v(" "),t("li",[e._v("容器编排工具：\n"),t("ol",[t("li",[t("a",{attrs:{href:"http://kubernetes.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kubernetes"),t("OutboundLink")],1),e._v(" "),t("ol",[t("li",[e._v("kubernetes特性：\n"),t("ol",[t("li",[e._v("自动包装")]),e._v(" "),t("li",[e._v("自我修复")]),e._v(" "),t("li",[e._v("服务发现和负载均衡")]),e._v(" "),t("li",[e._v("自动部署回滚")]),e._v(" "),t("li",[e._v("批处理")])])])])])])]),e._v(" "),t("li",[e._v("操作系统")]),e._v(" "),t("li",[e._v("容器镜像仓库\n"),t("ol",[t("li",[t("a",{attrs:{href:"https://github.com/docker/distribution",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker Registry"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://hub.docker.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker Hub"),t("OutboundLink")],1)])])]),e._v(" "),t("li",[e._v("监控\n"),t("ul",[t("li",[e._v("容器输出的日志可以很方便与已有日志收集工具整合。容器监控软件通常关注容器的资源使用情况（CPU、内存）。")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/google/cadvisor",target:"_blank",rel:"noopener noreferrer"}},[e._v("cAdvisor"),t("OutboundLink")],1)])])])]),e._v(" "),t("ul",[t("li",[t("h1",{attrs:{id:"machine、swarm、compose、socketplane这些docker生态圈软件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#machine、swarm、compose、socketplane这些docker生态圈软件"}},[e._v("#")]),e._v(" Machine、Swarm、Compose、SocketPlane这些Docker生态圈软件")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://docs.docker.com/machine/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Machine"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://docs.docker.com/swarm/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Swarm"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://docs.docker.com/compose/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Compose"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("SocketPlane： 为容器提供了一层虚拟网络，使得网络的配置不必那么繁琐。")])])])])])}),[],!1,null,null,null);r.default=a.exports}}]);