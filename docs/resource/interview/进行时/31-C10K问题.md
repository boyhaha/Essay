# 31-C10K问题

*   .这个概念最早由 Dan Kegel 提出，简单来说就是：单机1万个并发连接（FTP服务）问题，也就是说如何突破单机性能极限，更优化的处理高并发问题，

* 本质：
    * 本质上是操作系统的问题。对于Web1.0/2.0时代的操作系统而言， 传统的同步阻塞I/O模型都是一样的，并发10K和100的区别关键在于CPU。
    * 创建的进程线程多了，数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞）， 进程/线程上下文切换消耗大， 导致操作系统崩溃，这就是C10K问题的本质！
    * 关键就是尽可能减少这些CPU等核心计算资源消耗
* 解决思路：
    * 每个进程/线程处理一个连接
        * 资源占用过多，可扩展行差
    * 每个进程/线程同时处理多个连接（IO多路复用）
        * 解决方案：
            * select，poll，epoll（Linux独有），ICOP（Windows），libevent（跨平台）
              * select: 有I/O事件发生了，却并不知道是哪那几个流，所以具有O(n)的无差别轮询复杂度
              * pool: 和select差不多，只是没有最大连接数限制（因为其基于链表来存储的）
              * epoll：O(1)，也可以叫做Reactor，事件驱动，事件轮循（EventLoop）。特别适用于连接数量多，但活动连接较少的情况。
                * epoll 有两种工作模式，LT（水平触发）模式与 ET（边缘触发）模式。默认情况下，epoll 采用 LT 模式工作
                * 其实epoll 已经可以较好的处理 C10K 问题，但是如果要进一步的扩展，例如支持 10M 规模的并发连接，原有的技术就无能为力了
              * 但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。
            * <span style="background-color: #ffaaaa">协程（ 一种更轻量级的进程/线程）</span>
                * <span style="background-color: #ffaaaa">本质是异步非阻塞技术</span>
                * <span style="background-color: #ffaaaa">类似于同步阻塞，只不过同步阻塞是操作系统进行调度，而协程是自己内部进行调度</span>
                * 协程的优点是它比系统线程开销小，缺点是如果其中一个协程中有密集计算，其他的协程就不运行了。操作系统进程的缺点是开销大，优点是无论代码怎么写，所有进程都可以并发运行。
                    * 实际上同步阻塞程序的性能并不差，它的效率很高，不会浪费资源。当进程发生阻塞后，操作系统会将它挂起，不会分配CPU。直到数据到达才会分配CPU。多进程只是开多了之后副作用太大，因为进程多了互相切换有开销。所以如果一个服务器程序只有1000左右的并发连接，同步阻塞模式是最好的。
* ## 异步回调和协程
    * 协程虽然是用户态调度，实际上还是需要调度的，既然调度就会存在上下文切换。所以协程虽然比操作系统进程性能要好，但总还是有额外消耗的。而异步回调是没有切换开销的，它等同于顺序执行代码。所以异步回调程序的性能是要优于协程模型的。

* C10k
    * 当同时连接数在10K左右时，传统模型就不再适用。实际上在效率测试报告的线程切换开销一节可以看到，超过1K后性能就差的一塌糊涂了。
    * 进程模型
        * 在C10K的时候，启动和关闭这么多进程是不可接受的开销。事实上单纯的进程fork模型在C1K时就应当抛弃了。
    * 线程模型
        * 从任何测试都可以表明，线程模式比进程模式更耐久一些，性能更好。但是在面对C10K还是力不从心的。问题是，线程模式的问题出在哪里呢？
    * <span style="background-color: #ffaaaa">协程模型</span>
        * <span style="background-color: #ffaaaa">比系统开销更小，可以很轻易的处理高并发访问</span>
        * <span style="background-color: #ffaaaa">gevent，自动切换上下文</span>
    * 回调模型（CPS模型）
        * 在IO调用的时候，同时传入一个函数，作为返回函数。当IO结束时，调用传入的函数来处理下面的流程。
        * CPS模型：把一切操作都当作了IO，无论干什么，结果要通过回调函数来返回
    * 状态机模型
        * 本质是每次重入（基本已经不用）
