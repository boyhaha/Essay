# 08-异步

## 深入理解Python异步编程(上)原文链接：

##  [https://mp.weixin.qq.com/s?__biz=MzIxMjY5NTE0MA==&mid=2247483720&idx=1&sn=f016c06ddd17765fd50b705fed64429c](https://mp.weixin.qq.com/s?__biz=MzIxMjY5NTE0MA==&mid=2247483720&idx=1&sn=f016c06ddd17765fd50b705fed64429c)

* 2013年起由 Python 之父 Guido 亲自操刀主持了Tulip(asyncio)项目的开发

1. 概念
    * 并行
        * 是为了利用多核加速多任务完成的进度
    * 并发
        * 是为了让独立的子任务都有机会被尽快执行，但不一定能加速整体进度
    * 非阻塞
        * 是为了提高程序整体执行效率
    * 异步
        * 是高效地组织非阻塞任务的方式
    * 要支持并发，必须拆分为多任务，不同任务相对而言才有阻塞/非阻塞、同步/异步。所以，并发、异步、非阻塞三个词总是如影随形。
    * <span style="background-color: #ffaaaa">异步</span>
        * 以进程，线程，协程，函数/方法作为执行任务程序的基本单位，结合回调，事件循环，信号量等机制，以提高程序整体执行效率和并发能力的编程方式
        * 同步和异步的显著区别：
            * 有序和无序
    * 同步与异步
        * **同步**
        * **异步**
        * 区别就在于一个需要等待，一个不需要等待
2. 面临问题
    * 成本和效率
    * C10k/C10M挑战
        * 从技术角度挑战软硬件极限
    * 解决方案
        * I/O（
        * <span style="background-color: #ffaaaa">异步编程</span>
3. 异步I/O进化之路
    * 网络I/O是目前最大的I/O瓶颈，诸多
    * 以爬虫为例，从因特网下载十片文章
        * 同步阻塞方式
            * 依次下载，
            * 效率低下
        * 多进程
            * 开10个进程执行
            * 切换开销大，支持规模小（数十到数百）
        * 多线程
            * 线程的数据结构比进程更轻量级，同一个进程可以容纳多个线程
            * 支持规模不够大（数百个到数千个）
            * 主要问题： 竞态条件（无序，需要锁或者同步队列来保证下载顺序不会重复执行）
        * 非阻塞方式
            * 原始
            * 改进
                * epoll（linux）
                * 回调（callback）
                * 事件循环（
                    * 等待事件通知的循环
                    * 可以算作异步编程
                    * 支持规模达到（
                    * 问题：
                        * 回调层次过多时代码可读性差
                        * 破坏代码结构
                        * 共享状态管理困难
                        * 错误处理困难
4. Python对异步I/O的优化
    * 回调之痛，以始为终
        * 在
        * 代表作有 Tornado、Twisted、asyncio 等
    * 协程（

# [asyncio](https://www.lylinux.net/article/2019/6/9/57.html)

* asyncio

**import** threading

**import** asyncio

@asyncio.coroutine

**def** **hello**():

    print('Hello world! (%s)' % threading.currentThread())

**    yield** **from** asyncio.sleep(1)

    print('Hello again! (%s)' % threading.currentThread())

loop = asyncio.get_event_loop()

tasks = [hello(), hello()]

loop.run_until_complete(asyncio.wait(tasks))

loop.close()

如果把asyncio.sleep()换成真正的IO操作，则多个coroutine就可以由一个线程并发执行。

<span style="background-color: #ffaaaa"><span style="background-color: #ffaaaa">可以用单线程+</span><span style="background-color: #ffaaaa">coroutine</span><span style="background-color: #ffaaaa">实现多用户的高并发支持。</span></span>

* async / await
* asyncio

## asyncio中的基本概念

可以看见，使用asyncio库我们也可以在python代码中使用async和await。在asyncio中，有四个基本概念，分别是：

### Eventloop

Eventloop可以说是asyncio应用的核心，中央总控，Eventloop实例提供了注册、取消、执行任务和回调 的方法。 简单来说，就是我们可以把一些异步函数注册到这个事件循环上，事件循环回循环执行这些函数（每次只能执行一个），如果当前正在执行的函数在等待I/O返回，那么事件循环就会暂停它的执行去执行其他函数。当某个函数完成I/O后会恢复，等到下次循环到它的时候就会继续执行。

### Coroutine

协程本质就是一个函数，

### Future

Future是表示一个“未来”对象，类似于javascript中的promise，当异步操作结束后会把最终结果设置到这个Future对象上，Future是对协程的封装。

### Task

Eventloop除了支持协程，还支持注册Future和Task2种类型的对象，而Future是协程的封装，Future对象提供了很多任务方法（如完成后的回调，取消，设置任务结果等等），但是一般情况下开发者不需要操作Future这种底层对象，而是直接用Future的子类Task协同的调度协程来实现并发。那么什么是Task呢？下面介绍下：

_ 一个与__Future__类似的对象，可运行__Python__协程。非线程安全。�_�_Task__对象被用来在事件循环中运行协程。如果一个协程在等待一个__Future__对象，__Task__对象会挂起该协程的执行并等待该__Future__对象完成。当该__Future__对象完成被打包的协程将恢复执行。 事件循环使用协同日程调度: 一个事件循环每次运行一个__Task__对象。而一个__Task__对象会等待一个__Future__对象完成，该事件循环会运行其他__Task__、回调或执行IO操作。_

## 

## asyncio中一些常见用法的区别

### Asyncio.gather和asyncio.wait

1. asyncio.gather
2. asyncio.wait

### asyncio.create_task和loop.create_task以及asyncio.ensure_future

这三种方法都可以创建Task,从Python3.7开始可以统一的使用更高阶的asyncio.create_task.其实asyncio.create_task就是用的loop.create_task. loop.create_task接受的参数需要是一个协程，但是asyncio.ensure_future除了接受协程，还可以是Future对象或者awaitable对象：

1. 如果参数是协程，其底层使用
2. 如果是
3. 如果是一个

所以ensure_future方法主要就是确保这是一个Future对象，一般情况下直接用asyncio.create_task就可以了。

### 注册回调和执行同步代码

可以使用add_done_callback来添加成功回调：

def callback(future):

    print(f'Result: {future.result()}')

def callback2(future, n):

    print(f'Result: {future.result()}, N: {n}')

async def funa():

    await asyncio.sleep(1)

    return "funa"

async def main():

    task = asyncio.create_task(funa())

    task.add_done_callback(callback)

    await task

    #这样可以为callback传递参数

    task = asyncio.create_task(funa())

    task.add_done_callback(functools.partial(callback2, n=1))

    await task

if __name__ == '__main__':

    asyncio.run(main())

#### 执行同步代码

如果有同步逻辑，想要用asyncio来实现并发，那么需要怎么做呢？下面看看：

def a1():

    time.sleep(1)

    return "A"

async def b1():

    await asyncio.sleep(1)

    return "B"

async def main():

    loop = asyncio.get_running_loop()

    await asyncio.gather(loop.run_in_executor(None, a1), b1())

if __name__ == '__main__':

    start = time.perf_counter()

    asyncio.run(main())

    print(f'main method Cost: {time.perf_counter() - start}')

# 输出： main method Cost: 1.0050589740000002

可以使用run_into_executor来将同步函数逻辑转化成一个协程，第一个参数是要传递concurrent.futures.Executor实例的，传递None会选择默认的executor。
