---
sidebar: auto
---

# 08-异步

## [深入理解Python异步编程(上)](!https://mp.weixin.qq.com/s?__biz=MzIxMjY5NTE0MA==&mid=2247483720&idx=1&sn=f016c06ddd17765fd50b705fed64429c)

* 2013年起由 Python 之父 Guido 亲自操刀主持了Tulip(asyncio)项目的开发

1. 概念
    * 并行
        * 是为了利用多核加速多任务完成的进度
    * 并发
        * 是为了让独立的子任务都有机会被尽快执行，但不一定能加速整体进度
    * 非阻塞
        * 如果不能立刻得到结果，则该调用者不会阻塞当前线程
        * 是为了提高程序整体执行效率
    * 异步
        * 是高效地组织非阻塞任务的方式
    * 要支持并发，必须拆分为多任务，不同任务相对而言才有阻塞/非阻塞、同步/异步。所以，并发、异步、非阻塞三个词总是如影随形。
    * <span style="background-color: #ffaaaa">异步</span>
        * 以进程，线程，协程，函数/方法作为执行任务程序的基本单位，结合回调，事件循环，信号量等机制，以提高程序整体执行效率和并发能力的编程方式
        * 同步和异步的显著区别：
            * 有序和无序
    * 同步与异步
        * **同步**就是整个处理过程顺序执行，当各个过程都执行完毕，并返回结果。是一种线性执行的方式，执行的流程不能跨越。一般用于流程性比较强的程序，比如用户登录，需要对用户验证完成后才能登录系统。
        * **异步**则是只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕；而是继续执行下面的流程。是一种并行处理的方式，不必等待一个程序执行完，可以执行其它的任务，比如页面数据加载过程，不需要等所有数据获取后再显示页面。
      * 区别就在于一个需要等待，一个不需要等待

2. 面临问题
    * 成本和效率
    * C10k/C10M挑战
        * 从技术角度挑战软硬件极限
    * 解决方案
        * “除了瓶颈之外，任何改进都是幻觉。”  ------- 《约束理论与企业优化》
        * I/O（ 读写内存、读写磁盘、读写网卡）是限制计算机性能的最大瓶颈，
        * 异步I/O
3. 异步I/O进化之路
    * 网络I/O是目前最大的I/O瓶颈，诸多异步框架都对准的是网络I/O。
    * 以爬虫为例，从因特网下载十片文章
        * 同步阻塞方式
            * 依次下载，
            * 效率低下
        * 多进程
            * 开10个进程执行
            * 切换开销大，支持规模小（数十到数百）
        * 多线程
            * 线程的数据结构比进程更轻量级，同一个进程可以容纳多个线程
            * 支持规模不够大（数百个到数千个）
            * 主要问题： 竞态条件（无序，需要锁或者同步队列来保证下载顺序不会重复执行）
        * 非阻塞方式
            * 原始
            * 改进
                1. epoll（linux）：让应用程序可以通过select注册文件描述符和回调函数。当文件描述符的状态发生变化时，select 就调用事先注册的回调函数
                2. 向 selector 注册回调（callback）函数
                3. 事件循环（循环selector，获取当前正在发生的事件）
                    * 等待事件通知的循环
                    * 可以算作异步编程（并不是异步。本质上是同步I/O，需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的）
                    * 支持规模达到（数万到数十万个）
                    * 问题：
                        * 回调层次过多时代码可读性差
                        * 破坏代码结构
                        * 共享状态管理困难
                        * 错误处理困难
4. Python对异步I/O的优化
    * 回调之痛，以始为终
        * 在事件循环+回调的基础上衍生出了基于协程的解决方案
        * 代表作有 Tornado、Twisted、asyncio 等

## asyncio 
[asyncio](https://www.lylinux.net/article/2019/6/9/57.html)

```python
import asyncio
import threading


@asyncio.coroutine
def hello():
    print('Hello world! (%s)' % threading.currentThread())
    yield from asyncio.sleep(1)
    print('Hello again! (%s)' % threading.currentThread())

loop = asyncio.get_event_loop()
tasks = [hello(), hello()]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()
```
如果把asyncio.sleep()换成真正的IO操作，则多个coroutine就可以由一个线程并发执行。

<span style="background-color: #ffaaaa"><span style="background-color: #ffaaaa">可以用单线程+</span><span style="background-color: #ffaaaa">coroutine</span><span style="background-color: #ffaaaa">实现多用户的高并发支持。</span></span>

* async / await
* asyncio实现了TCP、UDP、SSL等协议，aiohttp则是基于asyncio实现的HTTP框架。

## asyncio中的基本概念

可以看见，使用asyncio库我们也可以在python代码中使用async和await。在asyncio中，有四个基本概念，分别是：

### Eventloop

Eventloop可以说是asyncio应用的核心，中央总控，Eventloop实例提供了注册、取消、执行任务和回调 的方法。 简单来说，就是我们可以把一些异步函数注册到这个事件循环上，事件循环回循环执行这些函数（每次只能执行一个），如果当前正在执行的函数在等待I/O返回，那么事件循环就会暂停它的执行去执行其他函数。当某个函数完成I/O后会恢复，等到下次循环到它的时候就会继续执行。

### Coroutine

协程本质就是一个函数，

### Future

Future是表示一个“未来”对象，类似于javascript中的promise，当异步操作结束后会把最终结果设置到这个Future对象上，Future是对协程的封装。

### Task

Eventloop除了支持协程，还支持注册Future和Task2种类型的对象，而Future是协程的封装，Future对象提供了很多任务方法（如完成后的回调，取消，设置任务结果等等），但是一般情况下开发者不需要操作Future这种底层对象，而是直接用Future的子类Task协同的调度协程来实现并发。那么什么是Task呢？下面介绍下：

一个与Future类似的对象，可运行__Python__协程。非线程安全。Tas对象被用来在事件循环中运行协程。如果一个协程在等待一个Future对象，Task对象会挂起该协程的执行并等待该Future对象完成。当该Future对象完成被打包的协程将恢复执行。 事件循环使用协程调度； 一个事件循环每次运行一个Task对象。而一个Task对象等待一个Future对象完成时，该事件循环会运行其他Task、回调或执行IO操作。

## asyncio中一些常见用法的区别

### Asyncio.gather和asyncio.wait

1. wait执行顺序是随机的，gather执行顺序是有序的
2. gather和wait都能添加一组future，但gather更支持任务分组，而wait支持更低级别的精细操作
   1. wait持接受一个参数return_when，
   2. 在默认情况下，asyncio.wait会等待全部任务完成(return_when='ALL_COMPLETED')，
   3. 它还支持FIRST_COMPLETED（第一个协程完成就返回）和FIRST_EXCEPTION（出现第一个异常就返回）


### asyncio.create_task和loop.create_task以及asyncio.ensure_future

这三种方法都可以创建Task, 从Python3.7开始可以统一的使用更高阶的asyncio.create_task. 
其实asyncio.create_task就是用的loop.create_task. 
loop.create_task接受的参数需要是一个协程，
但是asyncio.ensure_future除了接受协程，还可以是Future对象或者awaitable对象：
   1. 如果参数是协程，其底层使用loop.create_task，返回Task对象
   2. 如果是Future对象会直接返回
   3. 如果是一个awaitable对象，会await这个对象的__await__方法，再执行一次ensure_future，最后返回Task或者Future。

所以ensure_future方法主要就是确保这是一个Future对象，一般情况下直接用asyncio.create_task就可以了。

### 注册回调和执行同步代码

可以使用add_done_callback来添加成功回调：
```
def callback(future):

    print(f'Result: {future.result()}')

def callback2(future, n):

    print(f'Result: {future.result()}, N: {n}')

async def funa():

    await asyncio.sleep(1)

    return "funa"

async def main():

    task = asyncio.create_task(funa())

    task.add_done_callback(callback)

    await task

    #这样可以为callback传递参数

    task = asyncio.create_task(funa())

    task.add_done_callback(functools.partial(callback2, n=1))

    await task

if __name__ == '__main__':

    asyncio.run(main())
```
#### 执行同步代码

如果有同步逻辑，想要用asyncio来实现并发，那么需要怎么做呢？下面看看：
```
def a1():

    time.sleep(1)

    return "A"

async def b1():

    await asyncio.sleep(1)

    return "B"

async def main():

    loop = asyncio.get_running_loop()

    await asyncio.gather(loop.run_in_executor(None, a1), b1())

if __name__ == '__main__':

    start = time.perf_counter()

    asyncio.run(main())

    print(f'main method Cost: {time.perf_counter() - start}')
```
> 输出： main method Cost: 1.0050589740000002

可以使用run_into_executor来将同步函数逻辑转化成一个协程，第一个参数是要传递concurrent.futures.Executor实例的，传递None会选择默认的executor。
