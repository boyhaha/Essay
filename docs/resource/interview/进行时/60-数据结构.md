# 60-数据结构

**问题**

* **顺序表和链表的区别**
    * 顺序表存储数据，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储
        * 存储空间连续，空间利用率高，但
        * 时间复杂度来说的话，适合索引查找
    * 链表则是什么时候存储数据什么时候申请空间，存储空间是分散的
        * 每次申请一个节点的空间，会产生很多空间碎片，而且每个数据元素携带指针，空间利用率低
        * 时间复杂度来说的话，适合插入，删除，移动

* **顺序表（Array）**
* **链表**
* 栈
    * 栈：只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运行
    * 栈内存由系统自动分配，
* 堆
    * 堆：类似与一棵树
    * 堆内存由语言系统环境管理
* 队列：
    * 队列是一种先进先出的（First In First Out）的线性表，简称FIFO。允许插入的一端为队尾，允许删除的一端为队头。

**链表**

* 链表是一种由节点（Node）组成的线性数据集合，每个节点通过指针指向下一个节点。它是一种由节点组成，并能用于表示序列的数据结构。
* **单链表**
* **双链表**
* **循环链表**
* 时间复杂度：
    * 索引：O\(n\)
    * 查找：O\(n\)
    * 插入：O\(1\)
    * 删除：O\(1\)

**栈**

* 栈是一个元素集合，支持两个基本操作：push用于将元素压入栈，pop用于删除栈顶元素。
* 后进先出的数据结构（Last In First Out, LIFO）
* 时间复杂度
    * 索引：O\(n\)
    * 查找：O\(n\)
    * 插入：O\(1\)
    * 删除：O\(1\)

**队列**

* 队列是一个元素集合，支持两种基本操作：enqueue 用于添加一个元素到队列，dequeue 用于删除队列中的一个元素。
* 先进先出的数据结构（First In First Out, FIFO）。
* 时间复杂度
    * 索引：O\(n\)
    * 查找：O\(n\)
    * 插入：O\(1\)
    * 删除：O\(1\)

**树**

* 树是无向、联通的无环图。

**二叉树**

* 二叉树是一个树形数据结构，每个节点最多可以有两个子节点，称为左子节点和右子节点。
* **满二叉树（Full Tree）**
* **完美二叉树（Perfect Binary）**
* **完全二叉树**

**二叉查找树**

* 二叉查找树（BST）是一种二叉树。其任何节点的值都大于等于左子树中的值，小于等于右子树中的值。
* 时间复杂度
    * 索引：O\(log\(n\)\)
    * 查找：O\(log\(n\)\)
    * 插入：O\(log\(n\)\)
    * 删除：O\(log\(n\)\)

![cdbdff448158f05c729d8c35086d7414.jpe](image/cdbdff448158f05c729d8c35086d7414.jpe)

**字典树**

* 字典树，又称为基数树或前缀树，是一种用于存储键值为字符串的动态集合或关联数组的查找树。树中的节点并不直接存储关联键值，而是该节点在树中的位置决定了其关联键值。一个节点的所有子节点都有相同的前缀，根节点则是空字符串。

![1569204872a02cb6d36be960673ddd35.jpe](image/1569204872a02cb6d36be960673ddd35.jpe)

**树状数组**

* 树状数组，又称为二进制索引树（Binary Indexed Tree，BIT），其概念上是树，但以数组实现。数组中的下标代表树中的节点，每个节点的父节点或子节点的下标可以通过位运算获得。数组中的每个元素都包含了预计算的区间值之和，在整个树更新的过程中，这些计算的值也同样会被更新。
* 时间复杂度
    * 区间求和：O\(log\(n\)\)
    * 更新：O\(log\(n\)\)

![5526d4828a9c73e16254b343c7b2ebf1.jpe](image/5526d4828a9c73e16254b343c7b2ebf1.jpe)

**线段树**

* 线段树是用于存储区间和线段的树形数据结构。它允许查找一个节点在若干条线段中出现的次数。
* 时间复杂度
    * 区间查找：O\(log\(n\)\)
    * 更新：O\(log\(n\)\)

![cd2ae9e3bd18e974ba7ded9f713962ed.jpe](image/cd2ae9e3bd18e974ba7ded9f713962ed.jpe)

**堆**

* 堆是一种基于树的满足某些特性的数据结构：整个堆中的所有父子节点的键值都满足相同的排序条件。堆分为最大堆和最小堆。在最大堆中，父节点的键值永远大于等于所有子节点的键值，根节点的键值是最大的。最小堆中，父节点的键值永远小于等于所有子节点的键值，根节点的键值是最小的。
* 时间复杂度
    * 索引：O\(log\(n\)\)
    * 查找：O\(log\(n\)\)
    * 插入：O\(log\(n\)\)
    * 删除：O\(log\(n\)\)
    * 删除最大值/最小值：O\(1\)

![f830e26d538722d65e04eafba99572cd.jpe](image/f830e26d538722d65e04eafba99572cd.jpe)

**哈希**

* 哈希用于将任意长度的数据映射到固定长度的数据。哈希函数的返回值被称为哈希值、哈希码或者哈希。如果不同的主键得到相同的哈希值，则发生了冲突。
* **Hash Map**
* 冲突解决
    * **链地址法（**
    * **开放地址法（**

![f3a75d73b8c42b726b368133c684a329.jpe](image/f3a75d73b8c42b726b368133c684a329.jpe)

**图**

* 图是G =（V，E）的有序对，其包括顶点或节点的集合 V 以及边或弧的集合E，其中E包括了两个来自V的元素（即边与两个顶点相关联 ，并且该关联为这两个顶点的无序对）。
* **无向图**
* **有向图**

![18749f21c876e571e7b22452cf39377f.jpe](image/18749f21c876e571e7b22452cf39377f.jpe)
