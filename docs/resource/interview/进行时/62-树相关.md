# 62-树相关

**深度优先****搜索**

* 深度（Depth）优先搜索是一种先遍历子节点而不回溯的图遍历算法
* 时间复杂度：O(|V| + |E|)

**广度优先****搜索**

* 广度（Breadth）优先搜索是一种先遍历邻居节点而不是子节点的图遍历算法
* 时间复杂度：O(|V| + |E|)

![f115ee9d88f95aac3be324d42b6dfb35.gif](./image/f115ee9d88f95aac3be324d42b6dfb35.gif)

## **树的四种遍历方式**

```
class Node():
    # 节点类
    def __init__(self, data=-1):
        self.data = data
        self.left = None
        self.right = None

class Tree():
    # 树类
    def __init__(self):
        self.root = Node()

    def add(self, data):
        # 为树加入节点
        node = Node(data)
        if self.root.data == -1:  # 如果树为空，就对根节点赋值
            self.root = node
        else:
            myQueue = []
            treeNode = self.root
            myQueue.append(treeNode)
            while myQueue:  # 对已有的节点进行层次遍历
                treeNode = myQueue.pop(0)
                if not treeNode.left:
                    treeNode.left = node
                    return
                elif not treeNode.right:
                    treeNode.right = node
                    return
                else:
                    myQueue.append(treeNode.left)
                    myQueue.append(treeNode.right)

    def pre_order_recursion(self, root):  # 递归实现前序遍历   根左右
        if not root:
            return
        print(root.data),
        self.pre_order_recursion(root.left)
        self.pre_order_recursion(root.right)

    def in_order_recursion(self, root):  # 递归实现中序遍历   左根右
        if not root:
            return
        self.in_order_recursion(root.left)
        print(root.data),
        self.in_order_recursion(root.right)

    
    def post_order_recursion(self, root):  # 递归实现后序遍历   左右根
        if not root:
            return
        self.post_order_recursion(root.left)
        self.post_order_recursion(root.right)
        print(root.data),

    def level_order_queue(self, root):  # 队列实现层次遍历（非递归）
        if not root:
            return
        myQueue = []
        node = root
        myQueue.append(node)
        while myQueue:
            node = myQueue.pop(0)
            print(node.data),
            if node.left:
                myQueue.append(node.left)
            if node.right:
                myQueue.append(node.right)

    def pre_order_stack(self, root):  # 堆栈实现前序遍历（非递归）
        if not root:
            return
        myStack = []
        node = root
        while myStack or node:
            while node:  # 从根节点开始，一直寻找他的左子树
                print(node.data)
                myStack.append(node)
                node = node.left
            node = myStack.pop()  # while结束表示当前节点node为空，即前一个节点没有左子树了
            node = node.right  # 开始查看它的右子树

    def in_order_stack(self, root):  # 堆栈实现中序遍历（非递归）
        if not root:
            return
        myStack = []
        node = root
        while myStack or node:  # 从根节点开始，一直寻找它的左子树
            while node:
                myStack.append(node)
                node = node.left
            node = myStack.pop()
            print(node.data),
            node = node.right

    def post_order_stack(self, root):  # 堆栈实现后序遍历（非递归）
        # 先遍历根节点，再遍历右子树，最后是左子树，这样就可以转化为和先序遍历一个类型了，最后只把遍历结果逆序输出就OK了。
        if not root:
            return
        myStack1 = []
        # stack2是为了逆序输出
        myStack2 = []
        node = root
        while myStack1 or node:
            while node:
                myStack2.append(node)
                myStack1.append(node)
                node = node.right
            node = myStack1.pop()
            node = node.left
        while myStack2:
            print(myStack2.pop().data),
    

```
