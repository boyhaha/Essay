# 001-算法

* 实现n！后结尾有多少个零，如n=4，n！=24，有0个0，n=5，n!=120，有1个0

```
def count_zero(n):
    count = 0
    if n>5:
        k = n//5
        count = k + count_zero(k)
    return count
   
     # while num // 5 != 0:
    # count += num // 5
    # num = num //5
    # return count
```

* 给字符串，如“25525511123”实现算法，找出组成的ip地址的可能情况，如：['255.255.11.123','255.255.111.23']
    * 回溯法 递归
    * depth first search(dfs,深度优先搜索)

```
class Solution(object):
    def restoreIpAddresses(self, ip_str):
    result = []
    self.dfs(ip_str, [], result)
    return result

def dfs(self, ip_str, ip_part, result):
    if len(ip_str) > (4 - len(ip_part)) * 3:
        return
    if not ip_str and len(ip_part) == 4:
        result.append('.'.join(ip_part))
        return
    for i in range(min(3, len(ip_str))):
        curr = ip_str[:i + 1]
        if (curr[0] == '0' and len(curr) >= 2) or int(curr) > 255:
            continue
        self.dfs(ip_str[i + 1:], ip_part + [ip_str[:i + 1]], result)
```

* 给一个整数，如38，重复算出每个位数上数字之和，直至和为个位数，如3+8 =11，1+1 =2，满足条件，输出2

```
def count_zero(num):
    while num >= 10:
        num = num // 10 + num % 10
    return num

def count_zero_plus(num):
    num = 1 + (num - 1) % 9
    print(num)
```

* 给一个正整数 n, 找到若干个完全平方数(比如1, 4, 9, ... )使得他们的和等于 n。你需要让平方数的个数最少。
    * 动态规划
        * 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，
        * 每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。
        * 适用情况
            * 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
            * 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
            * 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规
        * 步骤：
            * 初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态
        * 使用场景：
            * 使用递归求斐波那契数列的时候，可以使用一个字典来保存计算结果，每次递归时，若能在字典中找到解，则直接返回。减少冗余运算

```
class Solution(object):
    _dp = [0]
    def numSquares(self, n):
        dp = self._dp
        while len(dp) <= n:
            # dp列表不断增大，dp[n]表示n的完美平方数
            # ，将后面的int转换为 元组，然后执行+=操作
            dp += min(dp[-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1,
        return dp[n]
```

* 请用两个队列实现一个栈
    * 堆栈数据结构只允许在一端进行操作，按照后进先出（LIFO, Last In First Out）的原理运作
    * 队列：

```
伪代码
    1.栈为空：当两个队列都为空的时候，栈为空
       2.入栈操作：选择非空队列入栈，若都为空，则随意
       3.出栈操作：当两个队列都为空的时候，引发错误“栈为空”；
            当队列Q2为空的时候，如果队列Q1中只有一个元素，则直接将队列1中的元素出队；
            如果队列1不止一个元素的时候，就将队列Q1的元素出队然后入队到队列2，直到队列Q1中只有一个元素，然后将队列1中的元素出队即可。
　　　　当队列Q1为空的时候，如果队列Q2中只有一个元素，则直接将队列Q2中的元素出队；
　　　　如果队列Q2不止一个元素的时候，就将队列Q2的元素出队然后入队到队列Q1，直到队列Q2中只有一个元素，然后将队列2中的元素出队即可。
```
