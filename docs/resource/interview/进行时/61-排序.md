# 61-排序

![sort.png](image/sort.png)

### **归并排序**

* 采用分治法的一个典型应用

def mergesort(seq):

    """归并排序"""

    if len(seq) <= 1:

        return seq

    mid = len(seq) // 2  # 将列表分成更小的两个列表

    # 分别对左右两个列表进行处理，分别返回两个排序好的列表

    left = mergesort(seq[:mid])

    right = mergesort(seq[mid:])

    # 对排序好的两个列表合并，产生一个新的排序好的列表

    return merge(left, right)

def merge(left, right):

    """合并两个已排序好的列表，产生一个新的已排序好的列表"""

    result = []  # 新的已排序好的列表

    i = 0  # 下标

    j = 0

    # 对两个列表中的元素 两两对比。

    # 将最小的元素，放到result中，并对当前列表下标加1

    while i < len(left) and j < len(right):

        if left[i] <= right[j]:

            result.append(left[i])

            i += 1

        else:

            result.append(right[j])

            j += 1

    result += left[i:]

    result += right[j:]

    return result

seq = [5,3,0,6,1,4]

print '排序前：',seq

result = mergesort(seq)

print '排序后：',result

**冒泡排序**

def bubbleSort(alist):

**    for** j **in** range(len(my_list)):

    _# -1__是因为每次比对的都是__i__与__i+1,__不减__1__的话__,__最后一次对比会超出__list__长度__,_

_     # -j__是因为__,__每一次大__loop__就代表排序好了一个最大值__,__放在了列表最后面__,__下次__loop__就不用再运算已经排序好了的值了_

        **for** i **in** range(len(my_list) - j- 1):

          **if** my_list[i] > my_list[i+1]: _#switch_

            my_list[i], my_list[i+1] = my_list[i+1], my_list[i]

    return alist

### **插入排序**

def insertionSort(alist):

for index in range(1, len(alist)):

    currentvalue = alist[index] _#_ _先记下来每次大循环走到的第几个元素的值_

    position = index

_     #_ _当前元素的左边的紧靠的元素比它大__,__要把左边的元素一个一个的往右移一位__,__给当前这个值插入到左边挪一个位置出来_

    while position > 0 and alist[position-1] > currentvalue:

        alist[position] = alist[position-1] _#_ _把左边的一个元素往右移一位_

        position -= 1 _#_ _只一次左移只能把当前元素一个位置_ _,__还得继续左移只到此元素放到排序好的列表的适当位置为止_

    alist[position] = currentvalue _#_ _已经找到了左边排序好的列表里不小于__current_val__的元素的位置__,__把__current_val__放在这里_

### **快速排序**

def quick_sort(array):

    if len(array) < 2:

        return array

    pivot = array[0]

    less_than_pivot = [x for x in array if x <= pivot]

    more_than_pivot = [x for x in array if x > pivot]

    return quick_sort(less_than_pivot) + [pivot] + quick_sort(more_than_pivot)

### **选择排序**

**def** selectionSort(arr):

    **for** i **in** range(len(arr) - 1):

        # 记录最小数的索引

        minIndex = i

        **for** j **in** range(i + 1, len(arr)):

            **if** arr[j] < arr[minIndex]:

                minIndex = j

        # i 不是最小数时，将 i 和最小数进行交换

        **if** i != minIndex:

            arr[i], arr[minIndex] = arr[minIndex], arr[i]

    **return** arr
