# 13-TCP

* Raw Socket ：原始套接字，可以实现上至应用层，下至链路层（ISO七层模型）的数据操作
* 七层模型
    * 应用，表示，会话，传输，网络，数据链路，物理
* 五层模型
    * 应用，传输，网络，数据链路，物理
* 网络协议
    * 从本质上来区分，HTTP，WebSocket，TCP，UDP，IP都是协议，而TCP/IP是不同协议的组合，你也可以称之为协议栈，协议族，TCP/IP模型等等
    * 而Socket（套接字）才是真正能操作的东西。Socket的本质是API，是先人对TCP/IP协议族的抽象或者说封装，它就像一个门面，给你一个操作TCP/IP协议的入口，来建立Socket连接。值得一提的是，此Socket是指网络编程下的Socket，而不是Unix中的Socket。虽然概念相似，但是Unix中的Socket不是基于这些乱七八糟的协议，而是基于操作系统本身的文件系统
    * 从分层上来区分，HTTP，WebSocket是应用层协议，TCP，UDP是传输层协议，IP是网络层协议
* TCP/IP模型
    * 网络接口层：ARP（地址解析协议）、RARP
    * 网际互联层：ICMP、IP
    * 传输层：TCP、UDP
        * TCP是面向连接的一种传输控制协议。TCP连接之后，客户端和服务器可以互相发送和接收消息，在客户端或者服务器没有主动断开之前，连接一直存在，故称为长连接。特点：连接有耗时，传输数据无大小限制，准确可靠，先发先至
        * UDP是无连接的用户数据报协议，所谓的无连接就是在传输数据之前不需要交换信息，没有握手建立连接的过程，只需要直接将对应的数据发送到指定的地址和端口就行。故UDP的特点是不稳定，速度快，可广播，一般数据包限定64KB之内，先发未必先至。
    * 应用层：DNS（基于UDP）、FTP（基于TCP）、HTTP（基于TCP）、WebSocket（基于TCP）、SMTP、TELNET、IRC、WHOIS
* HTTP、WebSocket与TCP的关系
    * HTTP通信过程属于“你推一下，我走一下”的方式，客户端不发请求则服务器永远无法发送数据给客户端，而WebSocket则在进行第一次HTTP请求之后，其他全部采用TCP通道进行双向通讯。所以，HTTP和WebSocket虽都是基于TCP协议，但是两者属于完全不同的两种通讯方式
* socket
    * 应用层和TCP/IP协议族通信的中间软件抽象层，是一组接口。
* TCP协议
    * 传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）
    * 是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义

```
from socket import *

# 创建socket
tcp_server_socket = socket(AF_INET, SOCK_STREAM)

# 本地信息
address = ('', 7788)

# 绑定
tcp_server_socket.bind(address)

# 使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了
tcp_server_socket.listen(128)

# 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务
# client_socket用来为这个客户端服务
# tcp_server_socket就可以省下来专门等待其他新客户端的链接
client_socket, clientAddr = tcp_server_socket.accept()

# 接收对方发送过来的数据
recv_data = client_socket.recv(1024) # 接收1024个字节
print('接收到的数据为:', recv_data.decode('gbk'))

# 发送一些数据到客户端
client_socket.send("thank you !".encode('gbk'))

# 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接
client_socket.close()
```

* 特点：
    * <span style="background-color: #ffaaaa">面向连接</span>
        * 双方建立连接才可以传输
        * 一对一，不适合广播
        * 三次握手，四次挥手
    * <span style="background-color: #ffaaaa">可靠传输</span>
        * 发送应答机制
        * 超时重传
            * 发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段
        * 错误校验
        * 流量控制和阻塞重传
            * 流量控制用来避免主机发送得过快而使接收方来不及完全收下
* 其他注意点
    * 关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。
    * 当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线

* **三次握手，**

**![8f4f3f002e8f6cb3f2366b67ab6a2660.png](image/8f4f3f002e8f6cb3f2366b67ab6a2660.png)**

* **题**
    * 如果四次挥手第四次ack 一直收不到怎么办
        * TCP超时重传
            * TCP重传间隔时间和TCP重传次数
                * 一般TCP报文的重传超时时间(RTO  
                    * TCP重传时间间隔有着多种不同的算法，最常见的就是《TCP/IP详解卷1》中关于超时重传的算法。具体算法不再赘述，请大家参考《TCP/IP详解卷1》第21章《TCP的超时与重传》。
                * SYN报文重传间隔时间
                    * 在实际情况下，由于SYN报文是TCP连接的第一个报文，如果该报文在传输的过程中丢弃了，那么发送方则无法测量RTT(
            * 报文重传的次数
                * TCP报文重传的次数也根据系统设置的不同而有区分，有些系统，一个报文只会被重传3次，如果重传三次后还未收到该报文的确认，那么就不再尝试重传，直接reset重置该TCP连接，但有些要求很高的业务应用系统，则会不断的重传被丢弃的报文，以尽最大可能保证业务数据的正常交互。
    * 为什么连接的时候是三次握手，关闭的时候却是四次握手？
        * 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，还要做一些其他的操作，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
    * 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
        * 为了保证发送的最后一个ACK报文段能够到达B
        * 防止“已失效的连接请求报文段”出现在本连接中。在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

* Tips
    * ip： 负责传输的IP协议
    * tcp：确保可靠性的TCP协议
    * dns：负责域名解析

    
