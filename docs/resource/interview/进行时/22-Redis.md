# 22-Redis

## 问题

1. 什么是Redis
    * Redis是一个开源的内存中的数据结构存储系统，它可以用作：**数据库、缓存和消息中间件**
    * 采用的是**单进程单线程**模型的 **KV 数据库**，**由C语言编写**
      * 4.0以前是单线程，
      * 4.0以后的版本引入了异步删除，由额外的线程执行（主要用于大数据量的异步删除）。
        * 例如：unlink key、flushdb async、flushall async
      * 6.0正式引入多线程。
        * 将主线程的 I/O 读写任务拆分给一组独立的子线程去执行
        * 所有的命令依旧是由主线程串行执行的，只不过具体的读写任务交给了子线程。
2. 有哪些数据结构？
    * 字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，位图（Bitmaps），Hyperloglogs 和地理空间（Geospatial）。其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。
3. 为什么是单线程的
    * 因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦，比如共享资源的保护）。
4. 为什么redis是单线程还这么快？
    1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
    2. 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
    3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
    4. 使用I/O多路复用模型，非阻塞IO；
        * I/O多路复用模型是利用 select/poll/epoll（Linux 采用的是 epoll，redis也是借助这一机制） 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。
        * **这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。**采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。
    5. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；
## REDIS
1. Redis会使用CRC16算法，将键和值写到某个节点上
   1. Redis Cluser采用虚拟槽分区，所有的键根据哈希函数映射到0~16383个整数槽内，
   2. 计算公式：slot=CRC16（key）&16383。
   3. 由于采用高质量的哈希算法，每个槽所映射的数据通常比较均匀。
2. redis内存淘汰策略
    * volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
    * volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
    * volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
    * allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
    * allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
    * noeviction：禁止驱逐数据，当内存使用达到阈值的时候，所有引起申请内存的命令会报错
3. 内存淘汰算法--LRU
    * 将空闲时间最长的淘汰掉
        * Redis3.0会提供一个待淘汰候选key的pool，里面默认有16个key，按照空闲时间排好序。更新时从Redis键空间随机选择N个key，分别计算它们的空闲时间idle，key只会在pool不满或者空闲时间大于pool里最小的时，才会进入pool，然后从pool中选择空闲时间最大的key淘汰掉。
4. redis优缺点
    * 优点
        * 读写性能优异
        * 支持数据持久化
        * 支持主从复制，可以进行读写分离
        * 数据结构丰富
    * 缺点
        * 数据库容量受到物理内存的限制,不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上
        * 可用性比较低
        * 主从复制是全量复制，比较消耗资源
5. 持久化方案
    * RDB（默认）
        * 采用快照的方式来进行数据持久化的,当符合快照的条件时Redis会自动对内存中的数据进行快照,然后持久化到硬盘中
          * 命令：
            * save：会阻塞redis服务器，不能处理其他命令
            * bigsave：会在后台异步进行快照操作，还可以处理其他命令
          * 自动触发：
            * “save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。
            * 默认为 save 900 1
        * fork出一个子进程进行持久化，并替换rdb文件
        * 因为是快照，所以会出现数据丢失
    * AOF
        * AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过**回放** AOF 日志中的写入指令来重新构建整个数据集。
        * 可以有很多不同的fsync策略：没有fsync，每秒fsync（默认），每次请求时fsync
        * 当AOF文件变得很大时，Redis会自动（或者手动使用bgrewriteaof）在后台进行重写。重写是绝对安全的，因为Redis继续往旧的文件中追加，使用创建当前数据集所需的最小操作集合来创建一个全新的文件，一旦第二个文件创建完毕，Redis就会切换这两个文件，并开始往新文件追加。
          * fork子进程进行重写，类似RDB，此时父进程还会初始化一个**重写缓冲区（管道）**，用于记录重写期间的操作，已保证数据完整。
    * 优缺点
      * RDB
        * RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复
        * RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快
        * RDB 进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据
      * AOF
        * 可以更好保护数据
        * 可以用于灾难性的误删除的的紧急恢复
        * 不过AOF文件通常会大于RDB文件
        * 
6. 常见概念
    * 缓存雪崩
        * 高并发情况下，当Redis服务器重启或者大量缓存在同一时期失效时,此时大量的流量会全部冲击到数据库上面,数据库有可能会因为承受不住而宕机
        * 解决办法
            * **均匀分布**
            * **熔断机制**
            * **限流机制**
            * 设置热点数据永不过期
    * 缓存穿透
        * 高并发情况下，查询一个不存在的值时，缓存不会被命中，导致大量请求直接落到数据库上
        * 解决办法
            * **布隆过滤**
              * 它实际上是一个很长的二进制向量和一系列随机映射函数
            * **缓存空值**
    * 缓存击穿
      * 高并发情况下，对一个特定的值进行查询，但是这个时候缓存正好过期了，缓存没有命中，导致大量请求直接落到数据库上
      * 解决办法
        * 设置热点数据永远不过期。
        * 设置互斥锁

    * 缓存预热
        * 系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题
        * 解决办法
            * 项目启动，自动缓存
            * 定时刷新缓存
    * 服务降级
        * 服务降级是不得已而为之的,在关键的时候丢卒保帅,保证核心功能正常运行
        * **服务拒绝**
        * **服务延迟**
7. 教训
    * 要进行Master-slave配置，出现服务故障时可以支持切换
    * 当达到最大内存时，会清空带有过期时间的key，即使key未到过期时间. 
    * redis与DB同步写的问题，先写DB，后写redis，因为写内存基本上没有问题
    * 当Redis物理内存使用超过内存总容量的3/5时就会开始比较危险了，就开始做swap,内存碎片大

## 基础

* redis是key-value的数据结构，每条数据都是一个键值对
* 键 Key
    * del
    * keys
    * exists
    * EXPIRE key seconds
        * 设置生存时间
    * sort
        * 排序
* 值的类型
    * string
        * APPEND key value
            * 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾
        * INCRBY key increment
            * 将 key 所储存的值加上增量 increment 。
        * STRLEN key
            * 返回 key 所储存的字符串值的长度。
        * SETNX key value
            * 将 key 的值设为 value ，当且仅当 key 不存在。
    * hash
        * HGETALL key
            * 返回哈希表 key 中，所有的域和值
        * HKEYS key
            * 返回哈希表 key 中，所有的域
        * HVALS key
            * 返回哈希表 key 中，所有的值
        * HLEN key
            * * 返回哈希表 key 中域的数量。
        * HSTRLEN key field
            * 返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度（string length）
    * list
        * LLEN key
          * 返回列表 key 的长度。
        * LINSERT key BEFORE|AFTER pivot value
            * 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。
            * 当 pivot 不存在于列表 key 时，不执行任何操作
        * LPUSH key value [value ...]
            * 将一个或多个值 value 插入到列表 key 的表头
        * LPOP key
            * 移除并返回列表 key 的头元素。
        * LRANGE key start stop
            * 返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。
        * LREM key count value
            * 根据参数 count 的值，移除列表中与参数 value 相等的元素。
    * set
        * SREM key member [member ...]
            * 移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。
                * O(N)， N 为给定 member 元素的数量。
    * sortedset
