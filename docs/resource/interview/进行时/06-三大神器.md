# 06-三大神器

* **知识点：**
    1. 装饰器
        1. 装饰器本质上是一个 Python 函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的
            * 闭包
                * 在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包。
                * 内部函数对外部函数作用域里变量的引用（非全局变量），则称内部函数为闭包
        2. 使用场景
            1. 参数检查，缓存，代理，提供上下文
    2. 迭代器（ Iterator）
        1. 迭代器是访问集合元素的一种方式
        2. 迭代器从集合的第一个元素开始访问，直到所有的元素被访问一遍后结束，迭代器只能前进不会后退
        3. 迭代器有两个基本的方法：next方法，返回下一个元素，
        4. 迭代（iteration）
            * 用简单的话讲，它就是从某个地方（比如一个列表）取出一个元素的过程。当我们使用一个循环来遍历某个东西时，这个过程本身就叫迭代。
    3. 生成器
        1. 使用了yield的函数被称为生成器，
        2. 使用
            1. 你不想同一时间将所有计算出来的大量结果集分配到内存当中，特别是结果集里还包含循环
            2. range Python2返回列表，Python3返回生成器

装饰器：

### 

### **例1:无参数的函数**

from time import ctime, sleep

def timefun\(func\):

    def wrapped\_func\(\):

        print\("%s called at %s" % \(func.\_\_name\_\_, ctime\(\)\)\)

        func\(\)

    return wrapped\_func

@timefun

def foo\(\):

    print\("I am foo"\)

foo\(\)

sleep\(2\)

foo\(\)

上面代码理解装饰器执行行为可理解成

foo = timefun\(foo\)

\# foo先作为参数赋值给func后,foo接收指向timefun返回的wrapped\_func

foo\(\)

\# 调用foo\(\),即等价调用wrapped\_func\(\)

\# 内部函数wrapped\_func被引用，所以外部函数的func变量\(自由变量\)并没有释放

\# func里保存的是原foo函数对象

### **例2:被装饰的函数有参数**

from time import ctime, sleep

def timefun\(func\):

    def wrapped\_func\(a, b\):

        print\("%s called at %s" % \(func.\_\_name\_\_, ctime\(\)\)\)

        print\(a, b\)

        func\(a, b\)

    return wrapped\_func

@timefun

def foo\(a, b\):

    print\(a\+b\)

foo\(3,5\)

sleep\(2\)

foo\(2,4\)

### **例3:被装饰的函数有不定长参数**

from time import ctime, sleep

def timefun\(func\):

    def wrapped\_func\(\*args, \*\*kwargs\):

        print\("%s called at %s"%\(func.\_\_name\_\_, ctime\(\)\)\)

        func\(\*args, \*\*kwargs\)

    return wrapped\_func

@timefun

def foo\(a, b, c\):

    print\(a\+b\+c\)

foo\(3,5,7\)

sleep\(2\)

foo\(2,4,9\)

### **例4:装饰器中的return**

from time import ctime, sleep

def timefun\(func\):

    def wrapped\_func\(\):

        print\("%s called at %s" % \(func.\_\_name\_\_, ctime\(\)\)\)

        ret = func\(\)

        return ret

    return wrapped\_func

@timefun

def foo\(\):

    print\("I am foo"\)

@timefun

def getInfo\(\):

    return '\-\-\-\-hahah\-\-\-'

foo\(\)

sleep\(2\)

foo\(\)

print\(getInfo\(\)\)

执行结果:

foo called at Fri Nov 4 21:55:57 2016

I am foo

foo called at Fri Nov 4 21:55:59 2016

I am foo

getInfo called at Fri Nov 4 21:55:59 2016

\-\-\-\-hahah\-\-\-

#### **总结：**

* 一般情况下为了让装饰器更通用，可以有return

### **例5:装饰器带参数,在原有装饰器的基础上，设置外部变量**

\#decorator2.py

from time import ctime, sleep

def timefun\_arg\(pre="hello"\):

    def timefun\(func\):

        def wrapped\_func\(\):

            print\("%s called at %s %s" % \(func.\_\_name\_\_, ctime\(\), pre\)\)

            return func\(\)

        return wrapped\_func

    return timefun

\# 下面的装饰过程

\# 1. 调用timefun\_arg\("itcast"\)

\# 2. 将步骤1得到的返回值，即time\_fun返回， 然后time\_fun\(foo\)

\# 3. 将time\_fun\(foo\)的结果返回，即wrapped\_func

\# 4. 让foo = wrapped\_fun，即foo现在指向wrapped\_func

@timefun\_arg\("itcast"\)

def foo\(\):

    print\("I am foo"\)

@timefun\_arg\("python"\)

def too\(\):

    print\("I am too"\)

foo\(\)

sleep\(2\)

foo\(\)

too\(\)

sleep\(2\)

too\(\)

可以理解为

foo\(\)==timefun\_arg\("itcast"\)\(foo\)\(\)

### **例6：类装饰器（扩展，非重点）**

装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重写了 \_\_call\_\_\(\) 方法，那么这个对象就是callable的。

class Test\(\):

    def \_\_call\_\_\(self\):

        print\('call me\!'\)

t = Test\(\)

t\(\) \# call me

类装饰器demo

class Test\(object\):

    def \_\_init\_\_\(self, func\):

        print\("\-\-\-初始化\-\-\-"\)

        print\("func name is %s"%func.\_\_name\_\_\)

        self.\_\_func = func

    def \_\_call\_\_\(self\):

        print\("\-\-\-装饰器中的功能\-\-\-"\)

        self.\_\_func\(\)

\#说明：

\#1. 当用Test来装作装饰器对test函数进行装饰的时候，首先会创建Test的实例对象

\# 并且会把func这个函数名当做参数传递到\_\_init\_\_方法中

\# 即在\_\_init\_\_方法中的属性\_\_func指向了func指向的函数

\#2. func指向了用Test创建出来的实例对象\#

\#3. 当在使用test\(\)进行调用时，就相当于让这个对象\(\)，因此会调用这个对象的\_\_call\_\_方法\#

\#4. 为了能够在\_\_call\_\_方法中调用原来test指向的函数体，

所以在\_\_init\_\_方法中就需要一个实例属性来保存这个函数体的引用

\# 所以才有了self.\_\_func = func这句代码，从而在调用\_\_call\_\_方法中能够调用到test之前的函数体

@Test

def test\(\):

    print\("\-\-\-\-test\-\-\-"\)

test\(\)

showpy\(\)\#如果把这句话注释，重新运行程序，依然会看到"\-\-初始化\-\-"

### 

* **题**
    1. 带参数的装饰器有几层
        1. 在原函数外层加了三层
    2. 分别描述类装饰器和函数装饰器的实现过程以及应用场景
        1. 实现原理
            * 类装饰器：
            * 函数装饰器：
        2. 应用场景
            * 插入日志、性能测试、事务处理、缓存、权限校验等
    3. yield的作用
        * yield是一个关键词，类似return, 不同之处在于，yield返回的是一个生成器
        * 而生成器是一种特殊的迭代器，它只会读取一次可迭代对象，实时生成数据，而不是读取可迭代对象的所有数据，相对而言会节约内存。
        * 回到yield，当函数内部使用yield代替return后，在你调用时，并不会立即执行，而是返回一个生成器对象
            * 可以借助for循环来遍历所以数据
            * 也可以通过next方法来获取下一条数据
            * 或者借助send传递附加数据
        * yield的作用：
            * 保存当前运行状态（断点），然后暂停执行，即将生成器挂起
            * 将yield关键字后面表达式的值作为返回值返回，
