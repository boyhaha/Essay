---
sidebar: auto
---
# 06-三大神器

## **题**
1. 带参数的装饰器有几层?
   1. 在原函数外层加了三层
2. 分别描述类装饰器和函数装饰器的实现过程以及应用场景
   1. 实现原理
      * 类装饰器：
      * 函数装饰器：
   2. 应用场景
      * 插入日志、性能测试、事务处理、缓存、权限校验等
3. yield的作用
   * yield是一个关键词，类似return, 不同之处在于，yield返回的是一个生成器
   * 而生成器是一种特殊的迭代器，它只会读取一次可迭代对象，实时生成数据，而不是读取可迭代对象的所有数据，相对而言会节约内存。
   * 回到yield，当函数内部使用yield代替return后，在你调用时，并不会立即执行，而是返回一个生成器对象
      * 可以借助for循环来遍历所以数据
      * 也可以通过next方法来获取下一条数据
      * 或者借助send传递附加数据
        * send(value)
        * value 参数是 send 方法向生成器发送的值，这个值会作为当前所在的 yield 表达式的结果
        * 返回值为 下一个 yield 后面的值
   * yield的作用：
      * 保存当前运行状态（断点），然后暂停执行，即将生成器挂起
      * 将yield关键字后面表达式的值作为返回值返回，

## **知识点：**
1. 装饰器
    1. 装饰器本质上是一个 Python 函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的
        * 闭包
            * 在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包。
            * 内部函数对外部函数作用域里变量的引用（非全局变量），则称内部函数为闭包
    2. 使用场景
        1. 参数检查，缓存，代理，提供上下文
2. 迭代器（ Iterator）
    1. 迭代器是访问集合元素的一种方式
    2. 只要实现了 `__next__`（py2为next） 方法
    3. 迭代器从集合的第一个元素开始访问，直到所有的元素被访问一遍后结束，迭代器只能前进不会后退
    4. 迭代器有两个基本的方法：`__next__`（py2为next）方法，返回下一个元素，__iter__方法，返回迭代器本身
    5. 迭代（iteration）
        * 用简单的话讲，它就是从某个地方（比如一个列表）取出一个元素的过程。当我们使用一个循环来遍历某个东西时，这个过程本身就叫迭代。
3. 生成器
    1. 使用了yield的函数被称为生成器，跟普通函数不同的是，生成器返回的是迭代器，只能用于迭代操作，所以说生成器是特殊的迭代器
    2. 使用
        1. 你不想同一时间将所有计算出来的大量结果集分配到内存当中，特别是结果集里还包含循环
        2. range Python2返回列表，Python3返回生成器



## 装饰器：

### **例1:无参数的函数**
```python
from time import ctime, sleep

def timefun(func):
    def wrapped_func():
        print("%s called at %s" % (func.__name__, ctime()))
        func()

    return wrapped_func

@timefun
def foo():

    print("I am foo")

foo()

sleep(2)

foo()
```
上面代码理解装饰器执行行为可理解成

```python
foo = timefun(foo)  # foo先作为参数赋值给func后,foo接收指向timefun返回的wrapped_func

"""
调用foo(),即等价调用wrapped_func(), 内部函数wrapped_func被引用，
所以外部函数的func变量(自由变量)并没有释放, 
func里保存的是原foo函数对象
"""
foo()
```



### **例2:被装饰的函数有参数**
```python
from time import ctime, sleep

def timefun(func):

    def wrapped_func(a, b):
        print("%s called at %s" % (func.__name__, ctime()))
        print(a, b)
        func(a, b)
    return wrapped_func

@timefun
def foo(a, b):
    print(a+b)

foo(3,5)

sleep(2)

foo(2,4)
```
### **例3:被装饰的函数有不定长参数**
```python
from time import ctime, sleep

def timefun(func):
    def wrapped_func(*args, **kwargs):
        print("%s called at %s"%(func.__name__, ctime()))
        func(*args, **kwargs)
    return wrapped_func

@timefun
def foo(a, b, c):

    print(a+b+c)

foo(3,5,7)

sleep(2)

foo(2,4,9)
```
### **例4:装饰器中的return**
```python
from time import ctime, sleep

def timefun(func):
    def wrapped_func():
        print("%s called at %s" % (func.__name__, ctime()))
        ret = func()

        return ret

    return wrapped_func

@timefun
def foo():

    print("I am foo")

@timefun
def getInfo():

    return '----hahah---'

foo()

sleep(2)

foo()

print(getInfo())
```
执行结果:
```
foo called at Fri Nov 4 21:55:57 2016

I am foo

foo called at Fri Nov 4 21:55:59 2016

I am foo

getInfo called at Fri Nov 4 21:55:59 2016

----hahah---
```
**总结：**

* 一般情况下为了让装饰器更通用，可以有return

### **例5:装饰器带参数,在原有装饰器的基础上，设置外部变量**
```python
#decorator2.py

from time import ctime, sleep

def timefun_arg(pre="hello"):

    def timefun(func):

        def wrapped_func():

            print("%s called at %s %s" % (func.__name__, ctime(), pre))

            return func()

        return wrapped_func

    return timefun
```
下面的装饰过程
1. 调用timefun_arg("itcast")
2. 将步骤1得到的返回值，即time_fun返回， 然后time_fun(foo)
3. 将time_fun(foo)的结果返回，即wrapped_func
4. 让foo = wrapped_fun，即foo现在指向wrapped_func
```python
@timefun_arg("itcast")
def foo():
    print("I am foo")

@timefun_arg("python")
def too():

    print("I am too")

foo()

sleep(2)

foo()

too()

sleep(2)

too()

```
可以理解为
> foo() = timefun_arg("itcast")(foo)()

### **例6：类装饰器（扩展，非重点）**

装饰器函数其实是一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重写了 `__call__`() 方法，那么这个对象就是callable的。
```python
class Test():

    def __call__(self):

        print('call me!')

t = Test()

t() # call me

# 类装饰器demo

class Test(object):

    def __init__(self, func):

        print("---初始化---")

        print("func name is %s"%func.__name__)

        self.__func = func

    def __call__(self):

        print("---装饰器中的功能---")

        self.__func()
```
说明：

1. 当用Test来装作装饰器对test函数进行装饰的时候，首先会创建Test的实例对象
   1. 并且会把func这个函数名当做参数传递到__init__方法中
   2. 即在__init__方法中的属性__func指向了func指向的函数
2. func指向了用Test创建出来的实例对象
3. 当在使用test()进行调用时，就相当于让这个对象()，因此会调用这个对象的__call__方法
4. 为了能够在__call__方法中调用原来test指向的函数体，所以在__init__方法中就需要一个实例属性来保存这个函数体的引用
5. 所以才有了self.__func = func这句代码，从而在调用__call__方法中能够调用到test之前的函数体
```python
@Test
def test():

    print("----test---")

test()

showpy()#如果把这句话注释，重新运行程序，依然会看到"--初始化--"
```

