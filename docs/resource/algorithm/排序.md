## 十大排序算法
## 基本概念
1. 排序的稳定性
   1. 在待排序序列中, 若多个相同关键字, 经过排序后, 他们之间的相对次序保持不变, 该算法是稳定的, 否则称为不稳定的
      1. 如果只是简单的进行数字的排序, 那么稳定性毫无意义
      2. 只有要排序的内容是一个复杂的对象的多个数字属性, 且原本的初始顺序存在意义, 那么才需要在二次排序的基础上保持原有排序的顺序. 例如: 一组原本按照价格高低排序的对象，如今需要按照销量高低排序，使用稳定性算法，可以使得想同销量的对象依旧保持着价格高低的排序展现，只有销量不同的才会重新排序
   1. 不稳定算法
      1. 快速排序, 堆排序, 希尔排序, 直接选择排序
   2. 稳定算法
      1. 冒泡排序, 基数排序, 归并排序, 直接插入排序, 折半插入排序, 归并排序
### 1. 冒泡排序
1. 重复走访要排序的数列, 一次比较两个元素, 如果顺序错误就把他们交换
2. 算法的由来: 越小的元素会经由交换慢慢 "浮" 到数列的顶端
3. 算法描述:
   1. 比较相邻元素. 如果第一个比第二个大, 就交换它们
   2. 对每一对相邻元素做同样的工作, 从开始第一对到结尾一对, 这样最后的元素就是最大的
   3. 针对所有的元素重复以上的步骤, 除了最后一个
   4. 重复1-3步骤, 直到排序完成
4. 代码示例
   1. Python
      * ```python
           def bubble_sort(array):
               """冒泡排序"""
               length = len(array)
               for j in range(0, length):
                  swap = False  # 是否交换标志
                  end = length - j - 1
                  for i in range(0, end):
                        if array[i] > array[i + 1]:
                           array[i + 1], array[i] = array[i], array[i + 1]
                           swap = True
                  if not swap:
                        break
               return array
           ```
   2. Golang
      * ```golang
         package alg
         func BubbleSort(array []int) ([]int) {
            swap := false
            for i := len(array)-1; i >= 0; i-- {
               for j := 0; j < i; j++ {
                  if array[j] > array[j+1]{
                     array[j], array[j+1] = array[j+1], array[j]
                     swap = true
                  }
               }
               if !swap {
                  break
               }
            }
            return array
         }
        ```
5. 复杂度:
   1. 数据完全有序是, 为O(n). 其他情况下, 几乎总是 O(n2)
6. 稳定排序
7. 适用场景: 算法复杂度高, 适合小数据排序, 不适合大数据排序

### 2. 快速排序
1. 从数列中挑出一个元素, 称为"基准"(pivot)
2. 分区: 所有比基准值小的元素摆放在基准前面, 比基准值大的放在基准后面(相同的数可以放在任何一边)
3. 递归的把小于基准值元素的子数列和大于基准值元素的子数列排序
4. 代码示例
   1. Python
      * ```python
           def quick_sort(array, low=0, high=None):
               """算法导论: 快速排序"""
               high = high or len(array) - 1
               if low < high:
                  mid = partition(array, low, high)
                  quick_sort(array, low, mid - 1)
                  quick_sort(array, mid + 1, high)
               return array


            def partition(array, low, high):
               pivot = array[low]
               i = low
               for j in range(i, high + 1):
                  if array[j] < pivot:
                        i += 1
                        array[i], array[j] = array[j], array[i]
               array[low], array[i] = array[i], array[low]
               return i
            
            # 利用额外空间
            def quickSort(arr):
               if(len(arr) < 2):  # 不用进行排序
                  return arr
               else:
                  pivot = arr[0]
                  less = [i for i in arr[1:] if(i <= pivot)]
                  great = [i for i in arr[1:] if(i > pivot)]
                  return quickSort(less) + [pivot] + quickSort(great)
           ```
   2. Golang
      * ```golang
         package alg

         import (
            "fmt"
         )


         func QuickSort(array []int) ([]int){
            Quick(array, 0, len(array) - 1)
            return array
         }

         func Quick(array []int, low int, high int){
            if low < high{
               var pivot int
               pivot = Partition(array, low, high)
               Quick(array, low, pivot - 1)
               Quick(array, pivot + 1, high)
            }
         }

         func Partition(array []int, low int, high int) (int){
            pivot := array[low]
            index := low
            for i := 0; i < high; i++{
               if array[i] < pivot{
                  index++
                  fmt.Println(index, i)
                  array[i], array[index] = array[index], array[i]
               }
            }
            array[low], array[index] = array[index], array[low]
            return index
         }

        ```


### 3. 归并排序