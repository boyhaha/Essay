---
sidebar: auto
---
# 基础 05-基本数据类型

**问题**

1. set，list区别
    1. List 是有序的，可以通过下标访问
    2. Set 是一组无序的，不能重复的元素，可用来做列表去重
2. python list 的数据结构是怎样的
   1. 在CPython中，列表被实现为长度可变（指数级）的数组
      1. 预先申请的空间大于列表长度
      2. 空间占满后会重新申请更大的空间，将原来的数据复制过去
   2. 由对其它对象的引用组成的连续数组

## **前言**
    * 有序的数据类型： 字符串，列表，元组
    * 无序的数据类型： 字典，集合
    * 区间问题
        * randint(a,b)          -> [a, b]
        * range(a,b)            -> [a,b)
        * [a:b]（切片操作） -> [a,b)

## **字符串**

        **常用操作**

1. <span style="background-color: #ffaaaa">python 字符串快速逆置</span>
    1. <span style="background-color: #ffaaaa">print(s[::-1])  # 从后向前，按步长为1进行取值</span>
2. basestring. 
3. mystr.split(str=" ", maxsplit=2)
   1. 以 str 为分隔符切片 mystr，如果 maxsplit有指定值，则仅分隔 maxsplit 个子字符串，结果为列表，len 为 maxsplit + 1
4. <span style="background-color: #ffaaaa">'str'.join(seq)</span>
    1. 以str为分隔符，将seq中的所有元素合并成一个新的字符串
    2. 返回值：以分隔符str连接各个元素好生成的字符串
    3. 使用 “+” 效率较低，建议使用join
5. 查找：
    1. str.find( "" )        返回索引,不存在返回-1
    2.  index                  ........,不存在会报异常(ValueError)
6.  替换：str.replace(str1, str2, count) count为替换次数
7. 'str'.strip 删除str字符串两端的空白字符

```
                    str='cast'
                    rel=str.strip("ct")
                    print(rel)
```

                        结果：  as

```
                    my_string = "wwwfewww"
                    result = my_string.strip("w")
```

                        结果: fe

```
                    my_string = "ww wew ww"
                    result = my_string.strip("w")
```

             结果:  wew (前后有空格)

## **列表**

1. 添加元素("增"append, extend, insert)
    1. 列表名.insert(index, 数据)：在指定位置插入数据(位置前有空元素会补位)
    2. 现有的列表下标是0-4，如果我们要在下标是6的地方插入数据，那个会自动插入到下标为5的地方，也就是插入到最后
2. 列表的排序
    1. sort 将list按特定顺序排序，默认从小到大， 参数reverse=True 可以改为倒序，由大到小
        1. sort为永久性排序
        2. 内置sorted（），临时排序，不会修改原来数据
    2. reverse 方法是将列表逆置。
3. 列表的删除

| func           | desc                                  |
| -------------- | ------------------------------------- |
| del my_list[2] | 删除指定索引的元素                    |
| my_list.pop( ) | 删除列表最后一个元素,并返回删除的元素 |
| remove( 元素 ) | 删除第一个出现的指定元素              |
| clear( )       | 清空列表                              |
|                |                                       |

## **元组（Tuple）**
    * 元组的元素不能修改、删除
    * 创建一个有且仅有一个元素的元组，
        * 格式：  元组名 = （元素1，）
* 元组的意义： 保证数据安全。

## **字典（dictionary**
1. 字典的key可以是任意数据类型，但不能是可变数据类型，而且不可变的数据类型中某个元素也不能是可变的，
   * 例：（1,2，[1,2]）
2. 根据键访问值(key唯一)，若键不存在，会报错。
   * age = info.get('age', 18)
   * 若info中不存在'age'这个键，就返回默认值18，不会对字典做任何操作，若没有返回值，返回None
   * 若info中存在'age'这个键，就返回对应的值
3. age = info.setdefault('age', 18) 
   * 若info中不存在'age'这个键，就返回默认值18，并把该键值对插入字典中，若没有返回值，返回None
   * 若info中存在'age'这个键，就返回对应的值

4. 删除字典：
   1. del  info /  info.clear()               删除（清空字典）
   2. del info[key]                           删除指定键值对，key 不存在会报错，
   3. info.pop(key[,default])                 删除指定键值对，key 若不存在,返回default值，不设返回值会报错
   4. popiteam(）                             随机返回并删除字典中的一个键值对


5. 字典的其他内置函数

| func                               | desc                                                                      |
| ---------------------------------- | ------------------------------------------------------------------------- |
| dict.copy()                        | 返回一个字典的浅拷贝                                                      |
| dict.fromkeys(seq, [val])          | 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值, 默认为None |
| dict.update(dict2)                 | 把字典dict2的键/值对更新到dict里（key相同的话会覆盖之前的value）          |
| dict.has_key(key)                  | 如果键在字典dict里返回true，否则返回false                                 |
| dict.get(key, default=None)        | 返回指定键的值，如果值不在字典中返回default值                             |
| dict.setdefault(key, default=None) | 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default          |
| dict.keys()                        | 以列表返回一个字典所有的键                                                |
| dict.values()                      | 以列表返回字典中的所有值                                                  |
| dict.items()                       | 返回列表 [("键", "值").............]                                      |

## **集合**
* 特点
  1. 合是无序的，元素唯一，
  2. 集合可以保存任意不可变的数据类型
* 定义空集合  
       my_set = set()
  * set.add(),添加单个任意元素，                                                                              -----》
  * set.update()，把要传入的元素（字符串）拆分，作为个体（字符）传入集合         -----》
* <span style="background-color: #ffaaaa">删除元素</span>
  * set.remove()          删除集合中的元素，如果有，直接删除，没有会报错。
  * set.discard()          删除集合中的元素，如果有，直接删除，没有的话不做操作。
  * set.pop()               随机删除集合中的元素，如果集合中没有元素，会报错。
* 交集（&）并集 （ | ） 差集（ - ）对称差集（ ^ ）

* <span style="background-color: #ffaaaa">enumarate() 用于将一个可遍历的数据对象（如列表，元组，字符串等）组合成一个索引序列，同时列出数据和下标，一般用于for循环</span>

* **公共方法**

| 运算符 | 表达式             | 结果                         | 描述           | 支持的数据类型           |
| ------ | ------------------ | ---------------------------- | -------------- | ------------------------ |
| +      | [2] + [3, 4]       | [1, 2, 3, 4]                 | 合并           | 字符串、列表、元组       |
| *      | ['Hi!'] * 4        | ['Hi!', 'Hi!', 'Hi!', 'Hi!'] | 复制           | 字符串、列表、元组       |
| in     | 1 in (1, 2, 3)     | True                         | 元素是否存在   | 字符串、列表、元组、字典 |
| not in | 5 not in (1, 2, 3) | True                         | 元素是否不存在 | 字符串、列表、元组、字典 |

## **内置函数**
    * len(item),
    * max(item),
    * min(item),
    * del(item)
    * len操作字典时，返回的是键值对的个数
    * del有两种用法，一种是del加空格，另一种是del()

                     del a   /   del( a )

* zip( )   将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存
    * zip

```
>>>a = [1,2,3] 
>>> b = [4,5,6]
>>> c = [4,5,6,7,8] 
>>> zipped = zip(a,b) # 返回一个对象 
>>> zipped <zip object at 0x103abc288>
>>> list(zipped) # list() 转换为列表 [(1, 4), (2, 5), (3, 6)] 
>>> list(zip(a,c)) # 元素个数与最短的列表一致 [(1, 4), (2, 5), (3, 6)] 
>>> a1, a2 = zip(*zip(a,b)) # 与 zip 相反，*zip 可理解为解压，返回二维矩阵式 
>>> list(a1) [1, 2, 3] 
>>> list(a2) [4, 5, 6] 
```

## **字典和列表的不同以及使用字典的目的**

1. list是有序的，dict是无序的
2. list通过索引访问，dict使用key访问
3. list随着数量的正常增长要想查找元素的时间复杂度为O(n),dict不随数量而增长而变化，时间复杂度为O(1)
4. dict的占用内存稍比list大，会在1.5倍左右
5. dict的可读性更高
6. 特征决定用途：list一般可作为队列、堆栈使用，而dict一般作为聚合统计或者快速使用特征访问，可以存储一些有标识性的数据等
