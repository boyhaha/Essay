---
sidebar: auto
---
# 08-面向对象

## **问题**

1. 实现with语句，要实现那个魔方方法
    * 实现__enter__和__exit__方法后，就能通过with语句进行上下文管理
2. 类方法、实例方法、静态方法的区别
   1. 类方法使用classmethod标识，静态方法使用@staticmethod 来修饰。实例方法就是剩下的方法
   2. 都可以通过类名或对象名进行调用，不过实例方法通过类名进行调用时需要传入一个对象参数。

## **面向对象基础**

1. 类
   1. 经典类（旧式类）：class Hero:                    class Hero():
   2. 新式类：class Hero( object ):
   3. 区别：新式类都从object继承，经典类不需要。
      1. Python2中，经典类没有父类，新式类继承 object类
      2. Python3中，经典类和新式类都继承 object 类
   4. MRO(method resolution order 基类搜索顺序 / 多继承调用顺序)：
      1. 新式类：C3算法（merge 操作）
         * 遍历执行merge操作的序列，如果一个序列的第一个元素，在其他序列中也是第一个元素，或不在其他序列出现，则从所有执行merge操作序列中删除这个元素，合并到当前的mro中。merge操作后的序列，递归地执行merge操作，直到merge操作的序列为空 
      2. 旧式类：深度优先搜索
      3. 新式类相同父类只执行一次构造函数，经典类重复执行多次。

                
## 面向对象
1. 面向对象
   1. 在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法 
      1. `__str__`（ 必须有返回值）：返回一个字符串，作为这个对象的描述信息,追踪对象属性的变化；在使用print 输出时，默认打印对象的内存地址，如果类里面定义了__str__(self)方法，就会打印从这个方法中return的数据
      2. `__del__`()方法：经常会在  `__del__`() 方法中做一些处理
         1. 当有变量保存了一个对象的引用时，该对象的引用计数就会加  1
         2. 使用 del 删除变量指向的对象时，就会减少对象的引用计数（每次减 1 ），当引用计数为0 时，对象才会真的被删除（内存被回收）
      3. `__new__`方法
         1. __new__至少要有一个参数cls，代表要实例化的类
         2. __new__必须要有返回值，返回实例化出来的实例。可以return父类__new__出来的实例，或者直接是object的__new__出来的实例
         3. `return  object.__new__(cls)`

2. 继承
   1. 继承，子类会继承父类的__init__方法，所以子类会继承父类的属性
   2. 调用父类方法：
      1. super(child_class, child_object).parent_attribute(arg)
         1. super(FooChild, self).__init__()
         2. super(FooChild, self).bar(message)
      2. 使用super() 可以逐一调用所有的父类方法，并且只执行一次。调用顺序遵循mro类属性的顺序。
      3. super() 带参数版本，只支持新式类
         * super(cls, self).make_cake()
      4. super()的简化版，只支持新式类
         * super().make_cake()
      5. 如果继承了多个父类，且父类都有同名方法，则默认只执行第一个父类的(同名方法只执行一次，目前super()不支持执行多个父类的同名方法)
   3. 所以在以后的开发中，如果重写了父类的__init__方法，最好是先调用父类的这个方法，然后再添加自己的功能，（完成父类的初始化工作，以保证程序的稳定）
3. 封装
   1. 封装的意义：
      1. 将属性和方法放到一起作为一个整体，然后通过实例化对象来处理
      2. 隐藏内部细节，只需要和对象的方法和属性进行交互
      3. 可以对属性和方法增加权限
   2. 私有权限：在属性名或方法名前面加两个下划线__
      1. 不能通过对象处理，起到安全作用
      2. 如果子类继承了父类，子类就是继承父类的共有属性和共有方法，子类不能直接使用父类的私有属性和私有方法
         1. 子类可以调用父类的私有属性和私有方法，但是不合法
   3. dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型 列表；
   4. 带参数时，返回参数的属性、方法 列表。
      1. 如果参数包含方法__dir__()，该方法将被调用。
      2. 如果参数不包含__dir__()，该方法将最大限度地收集参数信息。
4. 多态 （定义时的类型和运行时的类型不一样，此时就称为多态）
   1. Python的多态，就是弱化类型（鸭子类型），重点在于对象参数是否有指定的属性和方法，如果有就认定合适，而不关心对象的类型是否正确。
      1. 传入不同的对象，（类型不同），都有相同的属性和方法，可以正常访问，称为多态
      3. 多态的作用：增强一个函数或者方法的复用性
5. 类属性和实例属性
   1. 类属性：就是类对象所拥有的属性，被所有类对象的实例对象所共有，在内存中只存在一个副本，类似于C++中的静态对象
   2. 实例属性：对象属性，无法通过**类名.属性名**进行访问
   3. 如果一个类有多个对象，每个对象的属性是各自保存的，都有各自独立的地址
   4. 如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性
6. 类方法和静态方法
   1. 类方法：修饰器@classmethod来标识其为类方法，（一般以cls作为第一个参数）
   2. 静态方法：通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数，可以通过对象和类来访问
7.  单例模式
    1.  确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，单例模式是一种对象创建型模式。
    2.  保证只有1个对象
    3.  只执行一次__init__方法
    4.  示例：
        ```python
             class Singleton(object):
                __instance = None
                __is_first = True
                def __new__(cls, age, name):  # 实例化
                    if not cls.__instance:
                        cls.__instance = object.__new__(cls)
                    return cls.__instance
                def __init__(self, age, name):  # 初始化
                    if self. __is_first:
                        self.age = age
                        self.name = name
                        Singleton. __is_first = False
        ```

                    
## 概念知识：
1. 面向对象（object oriented programing  OOP）：
   1. 博大，将一类事物的共同属性进行抽象，将其所有的属性、行为按功能进行集合；
   2. 把事物分解成不同的对象，建立对象的目的不是完成某一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为
   3. 可以加快开发速度，减少代码重复
2. 面向过程（ procedure oriented programing  POP）：
   1. 精深，思考到事物发展的每一步，细发如丝，考虑到任何一种可能发生的情况，一步步执行，判断，直至事物的结束。
   2. 根据业务逻辑用函数把这些步骤一步步实现，然后再一一调用（自顶向下，逐步细化）
   3. 随着系统的膨胀，面向过程将无法应付，最终崩溃
3. OOP, POP 优缺点：
   1. 面型对象： 
      1. 易维护、复用、扩展，系统使用灵活方便；
      2. 性能低于面向过程
   2. 面向过程：
      1. 性能更优，消耗资源少
      2. 难以维护、复用、扩展。
4. 类：具有相似内部状态和运动规律的实体集合（或抽象）
5. 对象：某一个类的具体存在

                

 
